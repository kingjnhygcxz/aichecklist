import express, { type Express, Request, Response } from "express";
import { createServer, type Server } from "http";
import { chatWithGemini, analyzeTaskPatterns, getProductivityTips } from "./gemini";
import helmet from "helmet";
import cors from "cors";
import rateLimit from "express-rate-limit";
import { storage } from "./storage";
import { User } from "@shared/schema";
import { registerEnhancedVoiceAuthRoutes } from "./enhanced-voice-auth-routes";
import { toUserSettings, toUserUpdate } from "./utils/settingsMapper";
import { generateTaskSuggestions, parseTasksFromTranscript } from "./openai";
import OpenAI from "openai";
import { domoAI } from "./domoai";
import { logger } from "./logger";
import { secureAuditLogger, createSecureDomoAIMiddleware, createAuditCompletionMiddleware } from "./secure-audit-logger";
import { processAudioBase64, compareVoiceFeatures, VoiceFeatures } from './voice-biometric';
import { WebSocketServer } from 'ws';
import { v4 as uuidv4 } from 'uuid';
import { db } from './db';
import { sharedTasks as sharedTasksTable, RecurringFrequency, users, tasks } from '@shared/schema';
import sharesRouter from './routes/shares';
import videoRouter from './routes/video';
import preferencesRouter from './routes/preferences';
import { setupSEORoutes } from './seo-routes';
import { eq, lt, desc } from 'drizzle-orm';
import { getApiKeys, saveApiKey } from './api-keys';
import {
  stripe,
  createStripeCustomer,
  startFreeTrial,
  createSubscription,
  getUserSubscription,
  cancelSubscription,
  handleStripeWebhook
} from './stripe';
import { insertFeedbackSchema, notifications, subscriptionPlans, communityTemplates, communityTemplateTasks, insertCommunityTemplateSchema, insertCommunityTemplateTaskSchema } from '@shared/schema';
import { notificationService } from './notification-service';
import { taskScheduler } from './scheduler';
import { templateManager } from './templateManager';
import { validateEmail, isEmailDeliverable, getEmailValidationMessage } from './neverbounce';
import { 
  generateVerificationToken, 
  storeVerificationToken, 
  sendVerificationEmail,
  getVerificationToken,
  removeVerificationToken,
  sendEmail,
  sendLoginCodeEmail
} from './email-service';
import * as crypto from 'crypto';
import * as bcrypt from 'bcrypt';
import * as path from 'path';
import * as fs from 'fs';

// Simple session storage for tracking logged-in users
const userSessions = new Map<string, number>(); // sessionId -> userId
global.userSessions = userSessions; // Make accessible to other modules

// Create OpenAI client for AIDOMO
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Helper function to create a session
function createSession(userId: number): string {
  const sessionId = uuidv4();
  userSessions.set(sessionId, userId);
  return sessionId;
}

// Helper function to get user ID from session
function getUserIdFromSession(sessionId: string): number | null {
  return userSessions.get(sessionId) || null;
}

// Helper function to clear session
function clearSession(sessionId: string): void {
  userSessions.delete(sessionId);
}

// Input validation middleware
function validateInput(requiredFields: string[]) {
  return (req: Request, res: Response, next: Function) => {
    const missingFields = requiredFields.filter(field => !req.body[field]);
    if (missingFields.length > 0) {
      return res.status(400).json({ 
        message: `Missing required fields: ${missingFields.join(', ')}` 
      });
    }
    
    // Sanitize inputs (basic)
    for (const field in req.body) {
      if (typeof req.body[field] === 'string') {
        req.body[field] = req.body[field].trim();
      }
    }
    
    next();
  };
}

// Authentication middleware to protect routes
function requireAuth(req: Request, res: Response, next: Function): void {
  const sessionId = req.headers.authorization?.replace('Bearer ', '');
  const userId = sessionId ? getUserIdFromSession(sessionId) : null;
  
  if (!userId) {
    res.status(401).json({ message: "Authentication required" });
    return;
  }
  
  // Add userId to request for use in route handlers
  (req as any).userId = userId;
  next();
}

// Input validation middleware for password reset routes
const validateRequest = (req: Request, res: Response, next: any) => {
  const ip = req.ip || req.connection.remoteAddress || 'unknown';
  const userAgent = req.get('User-Agent') || 'unknown';
  
  // Log the request for monitoring
  logger.info(`Request validation`, { 
    method: req.method, 
    path: req.path, 
    ip, 
    userAgent 
  });
  
  next();
};

// Error handling middleware
function handleRouteError(error: any, req: Request, res: Response, operation: string): void {
  const errorMessage = error instanceof Error ? error.message : String(error);
  logger.error(`${operation} failed:`, { error: errorMessage, path: req.path, method: req.method });
  
  // Don't expose internal errors in production
  const message = process.env.NODE_ENV === 'production' 
    ? "An error occurred. Please try again later."
    : errorMessage;
    
  res.status(500).json({ message });
}

// Helper function to calculate string similarity
function calculateSimilarity(str1: string, str2: string): number {
  const longer = str1.length > str2.length ? str1 : str2;
  const shorter = str1.length > str2.length ? str2 : str1;
  
  if (longer.length === 0) {
    return 1.0;
  }
  
  const editDistance = levenshteinDistance(longer, shorter);
  return (longer.length - editDistance) / longer.length;
}

// Levenshtein distance algorithm
function levenshteinDistance(str1: string, str2: string): number {
  const matrix = [];
  
  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }
  
  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }
  
  return matrix[str2.length][str1.length];
}

// Advanced voice pattern matching for trained users
function checkVoicePatternMatch(input: string, trainingData: any): boolean {
  const { samples, commonWords, averageLength } = trainingData;
  
  // Check if input matches any of the training samples with high similarity
  for (const sample of samples) {
    const similarity = calculateSimilarity(sample, input);
    if (similarity >= 0.85) { // Higher threshold for trained voices
      return true;
    }
  }
  
  // Check for common word patterns
  const inputWords = input.split(' ');
  const matchingWords = inputWords.filter(word => commonWords.includes(word));
  const wordMatchRatio = matchingWords.length / inputWords.length;
  
  // Length similarity check
  const lengthSimilarity = 1 - Math.abs(input.length - averageLength) / Math.max(input.length, averageLength);
  
  // Combined scoring: word pattern + length similarity
  const combinedScore = (wordMatchRatio * 0.7) + (lengthSimilarity * 0.3);
  
  return combinedScore >= 0.75; // 75% combined match threshold
}

// Cleanup expired shared tasks periodically
setInterval(async () => {
  try {
    const now = new Date();
    
    // Delete expired shared tasks from database
    const result = await db.delete(sharedTasksTable)
      .where(lt(sharedTasksTable.expiresAt, now));
    
    const rowCount = result.rowCount || 0;
    if (rowCount > 0) {
      logger.info(`Deleted ${rowCount} expired shared tasks`);
    }
  } catch (error) {
    logger.error('Error cleaning up expired shared tasks', { error });
  }
}, 60 * 60 * 1000); // Check every hour

export async function registerRoutes(app: Express): Promise<Server> {
  // Apply calendar rescheduling endpoint
  app.post('/api/calendar/apply-rescheduling', requireAuth, async (req, res) => {
    try {
      const userId = (req as any).userId;
      const { changes } = req.body;
      
      if (!changes || !Array.isArray(changes)) {
        return res.status(400).json({ error: 'Invalid rescheduling changes' });
      }
      
      // Apply the rescheduling changes
      const updatedTasks = await storage.applyRescheduling(userId, changes);
      
      res.json({ 
        success: true, 
        updatedTasks,
        message: `Successfully rescheduled ${updatedTasks.length} event(s).`
      });
    } catch (error) {
      console.error('Error applying rescheduling:', error);
      res.status(500).json({ error: 'Failed to apply rescheduling' });
    }
  });
  
  // Health check endpoint for deployment verification
  app.get('/api/health', (req, res) => {
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || 'unknown',
      uptime: Math.round(process.uptime()),
      version: '1.0.0',
      database: 'connected'
    });
  });

  // Initialize default templates on server start
  await templateManager.initializeDefaultTemplates();
  
  // Add 7 new professional management templates
  const professionalTemplates = [
    {
      name: "Hospital Administrator System",
      description: "Ensure efficient healthcare delivery balancing patient safety, staffing, compliance, and financial performance with operational oversight and strategic planning",
      category: "Operations & Management",
      tags: ["healthcare", "hospital", "administrator", "patient-safety", "compliance", "medical", "leadership"],
      tasks: [
        // Daily Tasks
        { title: "Review ER, inpatient, and outpatient census reports", category: "Work", priority: "High" as any, timer: 30 },
        { title: "Handle urgent staff shortages or escalations", category: "Work", priority: "High" as any, timer: 45 },
        { title: "Monitor patient satisfaction and complaints", category: "Work", priority: "High" as any, timer: 20 },
        { title: "Ensure equipment and critical supplies are functional", category: "Work", priority: "High" as any, timer: 25 },
        { title: "Approve urgent procurement or medication requests", category: "Work", priority: "Medium" as any, timer: 15 },
        
        // Weekly Tasks
        { title: "Conduct leadership rounds with department heads", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 7 },
        { title: "Review staff schedules and overtime costs", category: "Work", priority: "High" as any, timer: 60, scheduledDaysFromNow: 7 },
        { title: "Audit hygiene, sanitation, and safety protocols", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 7 },
        { title: "Chair staff or medical council meetings", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 7 },
        { title: "Monitor insurance claims and billing accuracy", category: "Work", priority: "Medium" as any, timer: 45, scheduledDaysFromNow: 7 },
        
        // Monthly Tasks
        { title: "Analyze quality and patient outcome reports", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 30 },
        { title: "Present budget review with CFO and finance team", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 30 },
        { title: "Submit compliance documentation to regulators", category: "Work", priority: "High" as any, timer: 180, scheduledDaysFromNow: 30 },
        { title: "Host training workshops (emergency drills, safety refreshers)", category: "Work", priority: "High" as any, timer: 240, scheduledDaysFromNow: 30 },
        { title: "Meet with donors and community health stakeholders", category: "Work", priority: "Medium" as any, timer: 120, scheduledDaysFromNow: 30 }
      ]
    },
    {
      name: "Travel & Tourism Manager System",
      description: "Oversee bookings, partnerships, and customer experiences with vendor relations, seasonal packages, and emergency travel management",
      category: "Operations & Management",
      tags: ["travel", "tourism", "bookings", "hospitality", "vendors", "customer-service", "seasonal"],
      tasks: [
        // Daily Tasks
        { title: "Confirm and review upcoming client itineraries", category: "Work", priority: "High" as any, timer: 30 },
        { title: "Manage cancellations, rebookings, and emergencies", category: "Work", priority: "High" as any, timer: 45 },
        { title: "Monitor exchange rates and global travel advisories", category: "Work", priority: "Medium" as any, timer: 15 },
        { title: "Respond to customer inquiries and issues", category: "Work", priority: "High" as any, timer: 30 },
        
        // Weekly Tasks
        { title: "Negotiate rates with airlines, hotels, and tour partners", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 7 },
        { title: "Review and update promotional travel packages", category: "Work", priority: "Medium" as any, timer: 60, scheduledDaysFromNow: 7 },
        { title: "Track emerging travel trends among clients", category: "Work", priority: "Medium" as any, timer: 30, scheduledDaysFromNow: 7 },
        { title: "Train staff on destinations and policy changes", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 7 },
        { title: "Run promotional campaigns on social and email", category: "Work", priority: "Medium" as any, timer: 45, scheduledDaysFromNow: 7 },
        
        // Monthly Tasks
        { title: "Attend trade fairs and travel expos", category: "Work", priority: "High" as any, timer: 480, scheduledDaysFromNow: 30 },
        { title: "Audit financial performance of travel packages", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 30 },
        { title: "Refresh seasonal offers (holidays, summer/winter tours)", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 30 },
        { title: "Track and analyze customer satisfaction surveys", category: "Work", priority: "Medium" as any, timer: 60, scheduledDaysFromNow: 30 },
        { title: "Expand partnerships with local operators or guides", category: "Work", priority: "Medium" as any, timer: 90, scheduledDaysFromNow: 30 }
      ]
    },
    {
      name: "Esports Team Manager System",
      description: "Balance player performance, sponsor relations, and event logistics while maximizing fan engagement and commercial opportunities in competitive gaming",
      category: "Operations & Management",
      tags: ["esports", "gaming", "team-management", "sponsors", "performance", "streaming", "competitive"],
      tasks: [
        // Daily Tasks
        { title: "Confirm team practice and scrim schedule", category: "Work", priority: "High" as any, timer: 15 },
        { title: "Monitor player well-being (diet, sleep, exercise)", category: "Work", priority: "High" as any, timer: 20 },
        { title: "Review scrim results and game film (VODs)", category: "Work", priority: "High" as any, timer: 60 },
        { title: "Respond to sponsor or media requests", category: "Work", priority: "Medium" as any, timer: 30 },
        
        // Weekly Tasks
        { title: "Host strategic team/coaching sessions", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 7 },
        { title: "Oversee social media and streaming content schedule", category: "Work", priority: "Medium" as any, timer: 45, scheduledDaysFromNow: 7 },
        { title: "Track team fan engagement metrics", category: "Work", priority: "Medium" as any, timer: 30, scheduledDaysFromNow: 7 },
        { title: "Review travel and tournament logistics", category: "Work", priority: "High" as any, timer: 60, scheduledDaysFromNow: 7 },
        { title: "Scout competitors' strategies", category: "Work", priority: "Medium" as any, timer: 90, scheduledDaysFromNow: 7 },
        
        // Monthly Tasks
        { title: "Manage sponsor reporting and deliverables", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 30 },
        { title: "Review financials (salaries, prize pool, streaming income)", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 30 },
        { title: "Negotiate new sponsorship contracts", category: "Work", priority: "High" as any, timer: 180, scheduledDaysFromNow: 30 },
        { title: "Evaluate player performance and morale", category: "Work", priority: "High" as any, timer: 60, scheduledDaysFromNow: 30 },
        { title: "Plan bootcamps or international scrims", category: "Work", priority: "Medium" as any, timer: 120, scheduledDaysFromNow: 30 }
      ]
    },
    {
      name: "Construction Project Manager System",
      description: "Coordinate workers, subcontractors, materials, and schedules while ensuring safety, budget compliance, and quality standards throughout construction projects",
      category: "Operations & Management",
      tags: ["construction", "project-management", "safety", "subcontractors", "budget", "quality", "compliance"],
      tasks: [
        // Daily Tasks  
        { title: "Inspect job site safety and progress", category: "Work", priority: "High" as any, timer: 45 },
        { title: "Coordinate subcontractor activity and laborers", category: "Work", priority: "High" as any, timer: 30 },
        { title: "Review daily material deliveries and usage", category: "Work", priority: "Medium" as any, timer: 20 },
        { title: "Handle urgent compliance or hazard issues", category: "Work", priority: "High" as any, timer: 30 },
        
        // Weekly Tasks
        { title: "Conduct site coordination meetings", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 7 },
        { title: "Update project management software (e.g., Gantt chart)", category: "Work", priority: "High" as any, timer: 60, scheduledDaysFromNow: 7 },
        { title: "Review labor costs and timesheets", category: "Work", priority: "Medium" as any, timer: 45, scheduledDaysFromNow: 7 },
        { title: "Align project with architects/engineers on design changes", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 7 },
        { title: "Submit progress reports to stakeholders/clients", category: "Work", priority: "High" as any, timer: 60, scheduledDaysFromNow: 7 },
        
        // Monthly Tasks
        { title: "Compare budget vs. actual project costs", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 30 },
        { title: "Forecast project completion timelines", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 30 },
        { title: "Approve subcontractor payments and invoices", category: "Work", priority: "High" as any, timer: 60, scheduledDaysFromNow: 30 },
        { title: "Inspect and sign off on completed phases", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 30 },
        { title: "Prepare for upcoming large milestones", category: "Work", priority: "Medium" as any, timer: 90, scheduledDaysFromNow: 30 }
      ]
    },
    {
      name: "Strategic Shipping & Logistics Manager",
      description: "Oversee goods in transit, carrier performance, and customs compliance while balancing efficiency, cost savings, and customer satisfaction",
      category: "Operations & Management", 
      tags: ["shipping", "logistics", "supply-chain", "customs", "carriers", "freight", "strategic"],
      tasks: [
        // Daily Tasks
        { title: "Monitor shipment tracking and delivery updates", category: "Work", priority: "High" as any, timer: 30 },
        { title: "Resolve customs and clearance issues", category: "Work", priority: "High" as any, timer: 45 },
        { title: "Communicate with freight partners and drivers", category: "Work", priority: "Medium" as any, timer: 30 },
        { title: "Handle urgent delivery requests from clients", category: "Work", priority: "High" as any, timer: 25 },
        
        // Weekly Tasks
        { title: "Review carrier performance metrics (on-time rates, delays)", category: "Work", priority: "High" as any, timer: 60, scheduledDaysFromNow: 7 },
        { title: "Audit compliance documentation for shipments", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 7 },
        { title: "Negotiate and renegotiate shipping rates", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 7 },
        { title: "Check warehouse inventory and space usage", category: "Work", priority: "Medium" as any, timer: 45, scheduledDaysFromNow: 7 },
        { title: "Align logistics plans with sales/production", category: "Work", priority: "Medium" as any, timer: 60, scheduledDaysFromNow: 7 },
        
        // Monthly Tasks
        { title: "Analyze logistics costs vs. budget targets", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 30 },
        { title: "Renew or adjust freight/carrier contracts", category: "Work", priority: "High" as any, timer: 180, scheduledDaysFromNow: 30 },
        { title: "Audit safety certifications and compliance", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 30 },
        { title: "Update logistics software and ERP tools", category: "Work", priority: "Medium" as any, timer: 120, scheduledDaysFromNow: 30 },
        { title: "Present KPI and performance reports to leadership", category: "Work", priority: "High" as any, timer: 60, scheduledDaysFromNow: 30 }
      ]
    },
    {
      name: "Event Organizer & Wedding Planner System",
      description: "Manage guest experience, vendor relations, and flawless event execution with daily communication, vendor coordination, and budget management",
      category: "Operations & Management",
      tags: ["events", "weddings", "planning", "vendors", "guests", "coordination", "hospitality"],
      tasks: [
        // Daily Tasks
        { title: "Confirm and respond to client/vendor communications", category: "Work", priority: "High" as any, timer: 45 },
        { title: "Track guest list changes and RSVPs", category: "Work", priority: "Medium" as any, timer: 20 },
        { title: "Manage urgent cancellations or rescheduling requests", category: "Work", priority: "High" as any, timer: 30 },
        { title: "Review event logistics and on-site requirements", category: "Work", priority: "Medium" as any, timer: 25 },
        
        // Weekly Tasks
        { title: "Conduct vendor check-ins (caterers, decorators, AV)", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 7 },
        { title: "Schedule and run client progress meetings", category: "Work", priority: "High" as any, timer: 60, scheduledDaysFromNow: 7 },
        { title: "Manage catering tastings and menu selections", category: "Work", priority: "Medium" as any, timer: 120, scheduledDaysFromNow: 7 },
        { title: "Oversee rehearsal planning for weddings/events", category: "Work", priority: "High" as any, timer: 90, scheduledDaysFromNow: 7 },
        { title: "Track design and dÃ©cor production timelines", category: "Work", priority: "Medium" as any, timer: 45, scheduledDaysFromNow: 7 },
        
        // Monthly Tasks
        { title: "Finalize contracts and vendor deposits", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 30 },
        { title: "Update and monitor budget status", category: "Work", priority: "High" as any, timer: 60, scheduledDaysFromNow: 30 },
        { title: "Host or attend promotional events and expos", category: "Work", priority: "Medium" as any, timer: 240, scheduledDaysFromNow: 30 },
        { title: "Evaluate vendor performance and quality", category: "Work", priority: "Medium" as any, timer: 90, scheduledDaysFromNow: 30 },
        { title: "Expand venue and supplier partnerships", category: "Work", priority: "Medium" as any, timer: 120, scheduledDaysFromNow: 30 }
      ]
    },
    {
      name: "Hotel & Hospitality Manager System",
      description: "Ensure guest satisfaction, property upkeep, and profitable operations through daily service excellence and strategic revenue management",
      category: "Operations & Management",
      tags: ["hotel", "hospitality", "guest-service", "operations", "revenue", "property", "staff-management"],
      tasks: [
        // Daily Tasks
        { title: "Monitor guest check-ins, check-outs, and VIP arrivals", category: "Work", priority: "High" as any, timer: 30 },
        { title: "Review housekeeping schedules and room readiness", category: "Work", priority: "High" as any, timer: 20 },
        { title: "Handle guest complaints and resolve issues immediately", category: "Work", priority: "High" as any, timer: 45 },
        { title: "Oversee food & beverage service quality", category: "Work", priority: "Medium" as any, timer: 30 },
        
        // Weekly Tasks
        { title: "Train and coach staff for service excellence", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 7 },
        { title: "Review occupancy rates and forecast bookings", category: "Work", priority: "High" as any, timer: 45, scheduledDaysFromNow: 7 },
        { title: "Audit housekeeping, inventory, and supplies", category: "Work", priority: "Medium" as any, timer: 90, scheduledDaysFromNow: 7 },
        { title: "Track online guest reviews and respond where needed", category: "Work", priority: "Medium" as any, timer: 60, scheduledDaysFromNow: 7 },
        { title: "Align promotions with sales/marketing", category: "Work", priority: "Medium" as any, timer: 45, scheduledDaysFromNow: 7 },
        
        // Monthly Tasks
        { title: "Review property P&L and revenue growth", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 30 },
        { title: "Update seasonal offers/packages", category: "Work", priority: "Medium" as any, timer: 90, scheduledDaysFromNow: 30 },
        { title: "Inspect property maintenance and needed upgrades", category: "Work", priority: "High" as any, timer: 150, scheduledDaysFromNow: 30 },
        { title: "Launch staff recognition or reward programs", category: "Work", priority: "Medium" as any, timer: 90, scheduledDaysFromNow: 30 },
        { title: "Reassess competitive pricing strategies", category: "Work", priority: "High" as any, timer: 120, scheduledDaysFromNow: 30 }
      ]
    }
  ];
  
  // All specialized templates successfully added - cleaning up temporary code
  
  // Community Template Submission API
  app.post('/api/community-templates', async (req, res) => {
    try {
      const { name, description, category, tags, tasks, submittedByName, submittedByEmail, submittedByUserId } = req.body;
      
      // Create the community template
      const [template] = await db.insert(communityTemplates).values({
        name,
        description, 
        category,
        tags: tags || [],
        submittedByUserId,
        submittedByName,
        submittedByEmail,
        status: 'pending'
      }).returning();
      
      // Add tasks to the template
      if (tasks && tasks.length > 0) {
        const templateTasks = tasks.map((task: any, index: number) => ({
          templateId: template.id,
          title: task.title,
          category: task.category,
          priority: task.priority,
          timer: task.timer,
          scheduledDaysFromNow: task.scheduledDaysFromNow,
          displayOrder: index
        }));
        
        await db.insert(communityTemplateTasks).values(templateTasks);
      }
      
      res.json({ success: true, templateId: template.id });
    } catch (error) {
      console.error('Error submitting community template:', error);
      res.status(500).json({ error: 'Failed to submit template' });
    }
  });
  
  // Get community templates (approved only for regular users)
  app.get('/api/community-templates', async (req, res) => {
    try {
      const templates = await db.select({
        id: communityTemplates.id,
        name: communityTemplates.name,
        description: communityTemplates.description,
        category: communityTemplates.category,
        tags: communityTemplates.tags,
        submittedByName: communityTemplates.submittedByName,
        usageCount: communityTemplates.usageCount,
        rating: communityTemplates.rating,
        ratingCount: communityTemplates.ratingCount,
        createdAt: communityTemplates.createdAt
      })
      .from(communityTemplates)
      .where(eq(communityTemplates.status, 'approved'))
      .orderBy(desc(communityTemplates.usageCount), desc(communityTemplates.rating));
      
      res.json(templates);
    } catch (error) {
      console.error('Error fetching community templates:', error);
      res.status(500).json({ error: 'Failed to fetch templates' });
    }
  });
  
  // Get community template details with tasks
  app.get('/api/community-templates/:id', async (req, res) => {
    try {
      const templateId = parseInt(req.params.id);
      
      const [template] = await db.select()
        .from(communityTemplates)
        .where(eq(communityTemplates.id, templateId));
        
      if (!template || template.status !== 'approved') {
        return res.status(404).json({ error: 'Template not found' });
      }
      
      const tasks = await db.select()
        .from(communityTemplateTasks)
        .where(eq(communityTemplateTasks.templateId, templateId))
        .orderBy(communityTemplateTasks.displayOrder);
        
      res.json({ ...template, tasks });
    } catch (error) {
      console.error('Error fetching community template:', error);
      res.status(500).json({ error: 'Failed to fetch template' });
    }
  });
  
  // Note: New templates can be added through the templateManager.addTemplates() method
  // Templates are only added once and won't duplicate on server restart
  // Serve uploaded audio files with proper MIME types
  app.use('/attached_assets', express.static(path.resolve(import.meta.dirname, '..', 'attached_assets'), {
    setHeaders: (res, filePath) => {
      if (filePath.endsWith('.wav')) {
        res.setHeader('Content-Type', 'audio/wav');
      } else if (filePath.endsWith('.mp3')) {
        res.setHeader('Content-Type', 'audio/mpeg');
      } else if (filePath.endsWith('.png')) {
        res.setHeader('Content-Type', 'image/png');
      } else if (filePath.endsWith('.jpg') || filePath.endsWith('.jpeg')) {
        res.setHeader('Content-Type', 'image/jpeg');
      }
      res.setHeader('Cache-Control', 'public, max-age=31536000'); // Cache for 1 year
    }
  }));

  // Configure trust proxy for cloud hosting environments
  app.set('trust proxy', 1);

  // Security middleware - comprehensive protection against XSS, phishing, and injection attacks
  app.use(helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: process.env.NODE_ENV === 'development' 
          ? ["'self'", "'unsafe-inline'", "'unsafe-eval'", "https://fonts.googleapis.com"] // Dev: Allow Vite hot reload
          : ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"], // Prod: More restrictive
        scriptSrc: process.env.NODE_ENV === 'development'
          ? ["'self'", "'unsafe-inline'", "'unsafe-eval'", "https://va.vercel-scripts.com"] // Dev: Allow Vite
          : ["'self'", "https://va.vercel-scripts.com"], // Prod: No unsafe-inline/eval
        imgSrc: ["'self'", "data:", "https:", "blob:"],
        connectSrc: [
          "'self'", 
          "https://api.neverbounce.com", 
          "https://api.openai.com", 
          "https://api.anthropic.com",
          "https://api.gemini.google.com",
          "wss:", // Allow WebSocket connections
          process.env.NODE_ENV === 'development' ? "ws://localhost:*" : "" // Dev: Vite HMR
        ].filter(Boolean),
        fontSrc: ["'self'", "https://fonts.gstatic.com", "data:"],
        objectSrc: ["'none'"],
        mediaSrc: ["'self'", "blob:"],
        frameSrc: ["'none'", "https://streamable.com"], // Allow Streamable embeds, prevent other clickjacking
        frameAncestors: ["'none'"], // Prevent page from being embedded
        formAction: ["'self'"], // Prevent form submissions to external sites
      },
    },
    crossOriginEmbedderPolicy: false,
    hsts: process.env.NODE_ENV === 'production' ? {
      maxAge: 31536000, // 1 year
      includeSubDomains: true,
      preload: true
    } : false,
    referrerPolicy: { policy: "strict-origin-when-cross-origin" },
    noSniff: true, // Prevent MIME type sniffing
    xssFilter: true, // Enable XSS filtering
    originAgentCluster: true, // Prevent cross-origin attacks
  }));

  // CORS configuration
  app.use(cors({
    origin: process.env.NODE_ENV === 'production' 
      ? ['https://aichecklist.com', 'https://www.aichecklist.com'] 
      : ['http://localhost:5000', 'http://127.0.0.1:5000'],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization']
  }));

  // Rate limiting for authentication endpoints
  const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: process.env.NODE_ENV === 'development' ? 50 : 10, // More lenient in dev but still protected
    message: {
      error: "Too many authentication attempts, please try again later."
    },
    standardHeaders: true,
    legacyHeaders: false,
    // Never skip rate limiting for security
  });

  // Rate limiting for API endpoints
  const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: process.env.NODE_ENV === 'development' ? 500 : 100, // More lenient in dev but still protected
    message: {
      error: "Too many API requests, please try again later."
    },
    standardHeaders: true,
    legacyHeaders: false,
    // Skip rate limiting for HEAD requests (health checks)
    skip: (req) => req.method === 'HEAD'
  });

  // Apply rate limiting
  app.use('/api/register', authLimiter);
  app.use('/api/login', authLimiter);
  app.use('/api/voice-biometric-login', authLimiter);
  app.use('/api/', apiLimiter);

  // Authentication Routes
  app.post("/api/register", validateInput(['username', 'password', 'email']), async (req: Request, res: Response) => {
    try {
      const { username, email, password, voicePassword, voiceEnabled, termsAccepted, termsVersion } = req.body;
      
      // Validate terms acceptance - REQUIRED for competitive use protection
      if (!termsAccepted) {
        return res.status(400).json({ 
          message: "Terms of Service must be accepted to create an account. This includes competitive use restrictions." 
        });
      }
      
      // Check if username is already registered
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ message: "Username is already taken" });
      }

      // Check if email is already registered (if provided)
      if (email) {
        const existingEmail = await storage.getUserByEmail(email);
        if (existingEmail) {
          return res.status(400).json({ message: "Email is already registered" });
        }
      }

      // Create new user (unverified) with terms acceptance
      const newUser = await storage.createUser({
        username,
        email: email || null,
        password,
        voicePassword: voicePassword || null,
        voiceEnabled: voiceEnabled || false,
        emailVerifiedAt: null, // User starts unverified
        termsAcceptedAt: new Date(),
        termsVersion: termsVersion || 'v1.0'
      });

      logger.info(`New user registered: ${username}`, { userId: newUser.id, email: email || 'not provided' });
      
      // If email provided, send verification email
      if (email) {
        const token = generateVerificationToken();
        storeVerificationToken(token, email, newUser.id, username);
        
        const emailSent = await sendVerificationEmail(email, token, username);
        if (emailSent) {
          res.status(201).json({ 
            message: "Registration successful! Please check your email to verify your account.",
            requiresVerification: true,
            email: email
          });
        } else {
          logger.error(`Failed to send verification email to ${email}`);
          res.status(500).json({ message: "Registration successful, but failed to send verification email. Please contact support." });
        }
      } else {
        // No email - log in immediately (legacy flow)
        const sessionId = createSession(newUser.id);
        const { password: _, voicePassword: __, ...userResponse } = newUser;
        res.status(201).json({ 
          message: "Registration successful!",
          ...userResponse,
          sessionId
        });
      }
    } catch (error) {
      handleRouteError(error, req, res, "Registration");
    }
  });

  // Email verification endpoint
  app.get("/verify-email", async (req: Request, res: Response) => {
    try {
      const { token } = req.query;
      
      if (!token || typeof token !== 'string') {
        return res.status(400).send(`
          <html>
            <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
              <h2 style="color: #dc3545;">Invalid Verification Link</h2>
              <p>The verification link is invalid or malformed.</p>
              <a href="/" style="color: #007bff;">Return to Login</a>
            </body>
          </html>
        `);
      }

      const tokenData = getVerificationToken(token);
      if (!tokenData) {
        return res.status(400).send(`
          <html>
            <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
              <h2 style="color: #dc3545;">Verification Failed</h2>
              <p>The verification link has expired or is invalid.</p>
              <p>Please request a new verification email by registering again.</p>
              <a href="/" style="color: #007bff;">Return to Login</a>
            </body>
          </html>
        `);
      }

      // Mark email as verified
      await storage.updateUserEmailVerification(tokenData.userId, new Date());
      
      // Remove the verification token
      removeVerificationToken(token);
      
      logger.info(`Email verified for user: ${tokenData.username}`, { userId: tokenData.userId });

      res.status(200).send(`
        <html>
          <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
            <h2 style="color: #28a745;">Email Verified Successfully!</h2>
            <p>Your email address has been verified. You can now log in to your AIChecklist account.</p>
            <a href="/" style="background-color: #007bff; color: white; padding: 10px 20px; text-decoration: none; border-radius: 4px;">Go to Login</a>
          </body>
        </html>
      `);
    } catch (error) {
      logger.error('Email verification error:', error);
      res.status(500).send(`
        <html>
          <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
            <h2 style="color: #dc3545;">Verification Error</h2>
            <p>An error occurred during verification. Please try again later.</p>
            <a href="/" style="color: #007bff;">Return to Login</a>
          </body>
        </html>
      `);
    }
  });

  app.post("/api/login", validateInput(['username', 'password']), async (req: Request, res: Response) => {
    try {
      const { username, password } = req.body;
      
      const user = await storage.getUserByUsername(username);
      if (!user) {
        return res.status(401).json({ message: "Invalid credentials" });
      }

      // Verify password using bcrypt
      const isPasswordValid = await bcrypt.compare(password, user.password);
      if (!isPasswordValid) {
        return res.status(401).json({ message: "Invalid credentials" });
      }

      // Check email verification if user has an email
      if (user.email && !user.emailVerifiedAt) {
        return res.status(401).json({ 
          message: "Please verify your email address before logging in. Check your inbox for the verification link.",
          requiresVerification: true,
          email: user.email
        });
      }

      logger.info(`User logged in: ${user.username}`, { userId: user.id });
      
      // Create session for the user
      const sessionId = createSession(user.id);
      
      // Return user data without sensitive information
      const { password: _, voicePassword: __, ...userResponse } = user;
      res.json({ ...userResponse, sessionId });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Login failed: ${errorMessage}`);
      res.status(500).json({ message: "Login failed" });
    }
  });

  // Voice biometric login endpoint
  app.post("/api/voice-biometric-login", async (req: Request, res: Response) => {
    try {
      const { username, voiceData, transcribedText } = req.body;
      
      if (!username || !voiceData) {
        return res.status(400).json({ message: "Username and voice data are required" });
      }

      const user = await storage.getUserByUsername(username);
      if (!user || !user.voicePrint || !user.voicePassword) {
        logger.warn(`Voice biometric login attempt for user without voice setup: ${username}`);
        return res.status(401).json({ message: "Voice authentication not set up" });
      }

      // First, verify the spoken content matches the stored voice password
      if (transcribedText) {
        const normalizedSpoken = transcribedText.trim().toLowerCase();
        const normalizedStored = user.voicePassword.trim().toLowerCase();
        
        logger.info(`Voice content verification for user: ${user.username}`, { 
          expected: normalizedStored, 
          received: normalizedSpoken 
        });

        // Check if the spoken text matches the stored voice password
        const contentSimilarity = calculateSimilarity(normalizedStored, normalizedSpoken);
        if (contentSimilarity < 0.8) { // 80% text similarity required
          logger.warn(`Voice content mismatch for user: ${user.username}`, { 
            expected: normalizedStored, 
            received: normalizedSpoken, 
            similarity: contentSimilarity 
          });
          return res.status(401).json({ message: "Voice password incorrect" });
        }
      }

      // Then verify voice characteristics (biometric matching)
      const capturedFeatures = processAudioBase64(voiceData);
      const storedFeatures = JSON.parse(user.voiceFeatures || '{}') as VoiceFeatures;
      
      // Compare voice biometric features
      const biometricSimilarity = compareVoiceFeatures(storedFeatures, capturedFeatures);
      
      logger.info(`Voice biometric authentication for user: ${user.username}`, { 
        biometricSimilarity,
        threshold: 0.6 // Lowered threshold since we now have content verification
      });
      
      if (biometricSimilarity >= 0.6) { // 60% biometric similarity (lowered since we verify content)
        logger.info(`Voice authentication successful for user: ${user.username}`);
        
        // Create session for the user
        const sessionId = createSession(user.id);
        
        res.json({ 
          message: "Voice authentication successful",
          user: { id: user.id, username: user.username },
          sessionId
        });
      } else {
        logger.warn(`Voice biometric authentication failed for user: ${user.username}`, { biometricSimilarity });
        res.status(401).json({ message: "Voice pattern does not match" });
      }

    } catch (error) {
      logger.error("Voice biometric login error:", error);
      res.status(500).json({ message: "Voice authentication error" });
    }
  });

  // Simple email code authentication - Send login code
  app.post("/api/auth/send-code", async (req: Request, res: Response) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      
      // Generate 6-digit code
      const code = Math.floor(100000 + Math.random() * 900000).toString();
      
      // Check if user exists
      const existingUser = await storage.getUserByEmail(email);
      
      // Create login code
      await storage.createLoginCode(email, code, existingUser?.id);
      
      // Send code via email
      const emailSent = await sendLoginCodeEmail(email, code);
      
      if (emailSent) {
        logger.info(`Login code sent to ${email}`);
        res.json({ 
          message: "Login code sent to your email",
          exists: !!existingUser
        });
      } else {
        logger.error(`Failed to send login code to ${email}`);
        res.status(500).json({ message: "Failed to send login code. Please try again." });
      }
    } catch (error) {
      logger.error("Error sending login code:", error);
      res.status(500).json({ message: "Failed to send login code" });
    }
  });

  // Simple email code authentication - Verify code and log in
  app.post("/api/auth/verify-code", async (req: Request, res: Response) => {
    try {
      const { email, code, username } = req.body;
      
      if (!email || !code) {
        return res.status(400).json({ message: "Email and code are required" });
      }
      
      // Verify the code
      const loginCode = await storage.verifyLoginCode(email, code);
      
      if (!loginCode) {
        return res.status(401).json({ message: "Invalid or expired code" });
      }
      
      // Mark code as used
      await storage.markLoginCodeAsUsed(loginCode.id);
      
      let user;
      
      // If user exists, log them in
      if (loginCode.userId) {
        user = await storage.getUserById(loginCode.userId);
        
        // Mark email as verified if not already
        if (user && !user.emailVerifiedAt) {
          await storage.updateUserEmailVerification(user.id, new Date());
        }
      } else {
        // Create new user account
        const newUsername = username || email.split('@')[0] + Math.floor(Math.random() * 1000);
        
        // Generate random password (user won't need it with code auth)
        const randomPassword = await bcrypt.hash(crypto.randomBytes(32).toString('hex'), 10);
        
        user = await storage.createUser({
          username: newUsername,
          email,
          password: randomPassword,
          emailVerifiedAt: new Date(), // Auto-verify since they used email code
          termsAcceptedAt: new Date(),
          termsVersion: 'v1.0'
        });
        
        logger.info(`New user created via email code: ${newUsername}`, { userId: user.id, email });
      }
      
      if (!user) {
        return res.status(500).json({ message: "Failed to authenticate user" });
      }
      
      // Create session
      const sessionId = createSession(user.id);
      
      // Return user data without sensitive information
      const { password: _, voicePassword: __, ...userResponse } = user;
      
      res.json({ 
        message: loginCode.userId ? "Login successful" : "Account created successfully",
        ...userResponse,
        sessionId
      });
      
    } catch (error) {
      logger.error("Error verifying login code:", error);
      res.status(500).json({ message: "Failed to verify login code" });
    }
  });

  // Voice biometric setup endpoint
  app.post("/api/voice-biometric-setup", async (req: Request, res: Response) => {
    try {
      const { username, voiceData } = req.body;
      
      if (!username || !voiceData) {
        return res.status(400).json({ message: "Username and voice data are required" });
      }

      const user = await storage.getUserByUsername(username);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Extract voice features from recorded audio
      const voiceFeatures = processAudioBase64(voiceData);
      
      // Store voice biometric data
      await storage.updateVoiceBiometric(user.id, {
        voicePrint: voiceData,
        voiceFeatures: JSON.stringify(voiceFeatures)
      });
      
      logger.info(`Voice biometric setup completed for user: ${user.username}`);
      res.json({ message: "Voice biometric registered successfully" });

    } catch (error) {
      logger.error("Voice biometric setup error:", error);
      res.status(500).json({ message: "Voice setup error" });
    }
  });

  // Password reset request endpoint
  app.post("/api/forgot-password", validateRequest, async (req: Request, res: Response) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      
      const user = await storage.getUserByEmail(email);
      if (!user) {
        // Don't reveal if email exists or not for security
        return res.json({ message: "Password reset email sent if account exists" });
      }
      
      // Generate reset token
      const resetToken = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours
      
      await storage.createPasswordResetToken(user.id, user.email || '', resetToken, expiresAt);
      
      // Send password reset email
      const resetUrl = `${process.env.FRONTEND_URL || 'http://localhost:3000'}/reset-password?token=${resetToken}`;
      
      try {
        if (!user.email) {
          throw new Error("User email is required for password reset");
        }
        
        await sendEmail({
          to: user.email,
          from: process.env.FROM_EMAIL || 'noreply@aichecklist.io',
          subject: 'AIChecklist Password Reset',
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h2 style="color: #333;">Password Reset Request</h2>
              <p>Hello ${user.firstName || user.username},</p>
              <p>You requested to reset your password for your AIChecklist account. Click the button below to create a new password:</p>
              <div style="text-align: center; margin: 30px 0;">
                <a href="${resetUrl}" style="background-color: #10b981; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold;">Reset Password</a>
              </div>
              <p>This link will expire in 24 hours.</p>
              <p>If you didn't request this, you can safely ignore this email.</p>
              <hr style="margin: 30px 0; border: none; border-top: 1px solid #eee;">
              <p style="color: #666; font-size: 14px;">
                Best regards,<br>
                The AIChecklist Team<br>
                eagletechsoftware inc
              </p>
            </div>
          `
        });
        
        logger.info("Password reset email sent", { userId: user.id, email: user.email });
      } catch (emailError) {
        logger.error("Failed to send password reset email:", emailError);
        return res.status(500).json({ message: "Failed to send reset email" });
      }
      
      res.json({ message: "Password reset email sent if account exists" });
      
    } catch (error) {
      logger.error("Password reset request error:", error);
      res.status(500).json({ message: "Password reset request failed" });
    }
  });

  // Password reset endpoint
  app.post("/api/reset-password", validateRequest, async (req: Request, res: Response) => {
    try {
      const { token, newPassword, email } = req.body;
      
      if (!token || !newPassword || !email) {
        return res.status(400).json({ message: "Token, email, and new password are required" });
      }
      
      if (newPassword.length < 8) {
        return res.status(400).json({ message: "Password must be at least 8 characters long" });
      }
      
      const resetToken = await storage.getPasswordResetToken(token);
      if (!resetToken) {
        return res.status(400).json({ message: "Invalid or expired reset token" });
      }
      
      if (resetToken.isUsed) {
        return res.status(400).json({ message: "Reset token has already been used" });
      }
      
      if (new Date() > resetToken.expiresAt) {
        return res.status(400).json({ message: "Reset token has expired" });
      }
      
      // Validate that the email matches the token
      if (resetToken.email !== email) {
        return res.status(400).json({ message: "Invalid email for this reset token" });
      }
      
      // Hash the new password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update user password
      await storage.updateUserPassword(resetToken.userId, hashedPassword);
      
      // Mark token as used
      await storage.markPasswordResetTokenAsUsed(resetToken.id);
      
      logger.info("Password reset successful", { userId: resetToken.userId });
      res.json({ message: "Password reset successful" });
      
    } catch (error) {
      logger.error("Password reset error:", error);
      res.status(500).json({ message: "Password reset failed" });
    }
  });

  // Logout endpoint
  app.post("/api/logout", async (req: Request, res: Response) => {
    try {
      const sessionId = req.headers.authorization?.replace('Bearer ', '');
      if (sessionId) {
        clearSession(sessionId);
      }
      logger.info("User logout request");
      res.json({ message: "Logout successful" });
    } catch (error) {
      logger.error("Logout error:", error);
      res.status(500).json({ message: "Logout failed" });
    }
  });

  app.post("/api/voice-login", async (req: Request, res: Response) => {
    try {
      const { email, voicePassword } = req.body;
      
      const user = await storage.getUserByEmail(email);
      if (!user || !user.voiceEnabled) {
        return res.status(401).json({ message: "Voice authentication failed" });
      }

      // Normalize both passwords for comparison (trim whitespace and convert to lowercase)
      const normalizedInput = voicePassword.trim().toLowerCase();
      const normalizedStored = user.voicePassword?.trim().toLowerCase();
      
      logger.info(`Voice login attempt for user: ${email}`, { 
        expected: normalizedStored, 
        received: normalizedInput,
        expectedLength: normalizedStored?.length,
        receivedLength: normalizedInput.length,
        exactMatch: normalizedStored === normalizedInput
      });
      
      // Check for exact match first
      if (normalizedStored === normalizedInput) {
        logger.info(`Voice password exact match for user: ${email}`);
      } else {
        // If user has voice training data, use advanced matching
        if (user.voiceTrainingData) {
          const trainingData = JSON.parse(user.voiceTrainingData);
          const isVoiceMatch = checkVoicePatternMatch(normalizedInput, trainingData);
          
          if (!isVoiceMatch) {
            logger.warn(`Voice pattern mismatch for trained user: ${email}`, { 
              expected: normalizedStored, 
              received: normalizedInput 
            });
            return res.status(401).json({ message: "Voice authentication failed" });
          }
          logger.info(`Voice pattern match successful for user: ${email}`);
        } else {
          // Fallback to similarity matching for non-trained users
          const similarity = calculateSimilarity(normalizedStored || '', normalizedInput);
          logger.info(`Voice password similarity for user: ${email}`, { similarity });
          
          if (similarity < 0.6) { // 60% similarity threshold for more lenient matching
            logger.warn(`Voice password similarity too low for user: ${email}`, { 
              expected: normalizedStored, 
              received: normalizedInput,
              similarity 
            });
            return res.status(401).json({ message: "Voice authentication failed" });
          }
        }
      }

      logger.info(`User voice login successful: ${email}`, { userId: user.id });
      
      // Create session for the user
      const sessionId = createSession(user.id);
      
      // Return user data without sensitive information
      const { password: _, voicePassword: __, ...userResponse } = user;
      res.json({ ...userResponse, sessionId });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Voice login failed: ${errorMessage}`);
      res.status(500).json({ message: "Voice login failed" });
    }
  });

  // Tasks Routes
  app.get("/api/tasks", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      
      // Get tasks for the specific user
      const tasks = await storage.getAllTasks(userId);
      logger.debug(`Retrieved tasks`, { count: tasks.length });
      res.json(tasks);
    } catch (error) {
      logger.error("Failed to fetch tasks", { error });
      res.status(500).json({ message: "Failed to fetch tasks" });
    }
  });

  app.post("/api/tasks", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const task = req.body;
      
      // Basic validation
      if (!task.title || typeof task.title !== 'string' || task.title.trim().length === 0) {
        return res.status(400).json({ message: "Task title is required and must be a non-empty string" });
      }
      
      // Validate category and priority enums
      const validCategories = ["Work", "Personal", "Shopping", "Health", "Business", "Other"];
      const validPriorities = ["Low", "Medium", "High"];
      
      if (!validCategories.includes(task.category)) {
        return res.status(400).json({ message: "Invalid task category" });
      }
      
      if (!validPriorities.includes(task.priority)) {
        return res.status(400).json({ message: "Invalid task priority" });
      }
      
      // Add userId to task
      task.userId = userId;
      
      // Get user's timezone for proper time handling
      let userTimezone = 'America/New_York'; // Default to Eastern Time
      try {
        const userPrefs = await storage.getUserPreferences(userId);
        if (userPrefs && userPrefs.timezone) {
          userTimezone = userPrefs.timezone;
        }
      } catch (error) {
        logger.warn('Could not fetch user timezone, using default', { userId });
      }
      
      // Convert scheduledDate string to Date object if present
      if (task.scheduledDate && typeof task.scheduledDate === 'string') {
        // If scheduledTime is provided separately, reconstruct the date with correct time
        if (task.scheduledTime && typeof task.scheduledTime === 'string') {
          const [hours, minutes] = task.scheduledTime.split(':').map(Number);
          if (!isNaN(hours) && !isNaN(minutes)) {
            // Extract just the date part from the ISO string
            const dateOnly = task.scheduledDate.split('T')[0];
            
            // Create the date-time string in user's local time
            const timeString = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:00`;
            const localDateTimeString = `${dateOnly}T${timeString}`;
            
            // Parse as local time first
            const localDate = new Date(localDateTimeString);
            
            // Calculate timezone offset for the user's timezone
            // Eastern Time is UTC-5 (standard) or UTC-4 (daylight)
            // For now, assume UTC-4 during daylight saving time
            const timezoneOffsetHours = userTimezone === 'America/New_York' ? 4 : 0;
            
            // Adjust for timezone by adding the offset
            // This converts from user's local time to UTC
            const utcDate = new Date(localDate.getTime() + (timezoneOffsetHours * 60 * 60 * 1000));
            
            task.scheduledDate = utcDate;
            
            logger.info('Applied scheduledTime to task with timezone adjustment', {
              taskTitle: task.title,
              scheduledTime: task.scheduledTime,
              userTimezone,
              dateOnly,
              timeString,
              localDateTimeString,
              timezoneOffsetHours,
              resultingDate: task.scheduledDate.toISOString()
            });
          }
        } else {
          // Parse the date as-is
          task.scheduledDate = new Date(task.scheduledDate);
          
          logger.info('Processing scheduledDate without separate time', {
            taskTitle: task.title,
            providedDate: task.scheduledDate,
            resultingDate: task.scheduledDate.toISOString()
          });
        }
      }
      
      const createdTask = await storage.createTask(task);
      
      // Create reminder if task has a scheduled date
      if (createdTask.scheduledDate) {
        try {
          const { notificationService } = await import('./notification-service');
          await notificationService.createScheduledTaskReminder({
            id: createdTask.id,
            title: createdTask.title,
            userId: createdTask.userId,
            scheduledDate: new Date(createdTask.scheduledDate)
          });
          logger.info('Created reminder for scheduled task', { 
            taskId: createdTask.id, 
            scheduledDate: createdTask.scheduledDate 
          });
        } catch (reminderError) {
          logger.error('Failed to create reminder for scheduled task', { 
            taskId: createdTask.id, 
            error: reminderError 
          });
          // Don't fail the task creation if reminder creation fails
        }
      }
      
      // Update user statistics for new task
      try {
        const userStats = await storage.getUserStats(userId);
        const categoryUpdates: any = {};
        
        // Increment category-specific counter
        switch (task.category) {
          case "Work": categoryUpdates.workTasks = userStats.workTasks + 1; break;
          case "Personal": categoryUpdates.personalTasks = userStats.personalTasks + 1; break;
          case "Shopping": categoryUpdates.shoppingTasks = userStats.shoppingTasks + 1; break;
          case "Health": categoryUpdates.healthTasks = userStats.healthTasks + 1; break;
          case "Business": categoryUpdates.businessTasks = userStats.businessTasks + 1; break;
          case "Other": categoryUpdates.otherTasks = userStats.otherTasks + 1; break;
        }
        
        // Update total tasks count
        await storage.updateUserStats(userId, {
          totalTasks: userStats.totalTasks + 1,
          ...categoryUpdates
        });
        
        logger.info(`Updated user stats for new task`, { userId, category: task.category });
      } catch (error) {
        logger.error(`Failed to update user stats for new task`, { error, userId });
        // Don't fail the request if stats update fails
      }
      
      logger.info(`Task created successfully: ${createdTask.id}`, { taskTitle: createdTask.title, userId });
      res.status(201).json(createdTask);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to create task: ${errorMessage}`);
      res.status(500).json({ message: "Failed to create task", error: errorMessage });
    }
  });

  // Bulk reorder tasks endpoint
  app.patch("/api/tasks/reorder", requireAuth, async (req: Request, res: Response) => {
    try {
      const { taskOrders } = req.body; // Array of { id: string, displayOrder: number }
      const userId = (req as any).userId;
      
      if (!Array.isArray(taskOrders)) {
        return res.status(400).json({ message: "taskOrders must be an array" });
      }
      
      logger.info(`Bulk task reorder request received`, { userId, taskCount: taskOrders.length });
      
      // Update all tasks in a single transaction
      const updatePromises = taskOrders.map(async ({ id, displayOrder }) => {
        // Verify task belongs to user first (now handled by getTask with userId)
        const existingTask = await storage.getTask(id, userId);
        if (!existingTask) {
          throw new Error(`Task ${id} not found or access denied`);
        }
        return storage.updateTask(id, { displayOrder });
      });
      
      await Promise.all(updatePromises);
      
      logger.info(`Task reorder completed successfully`, { userId, taskCount: taskOrders.length });
      res.json({ message: "Tasks reordered successfully" });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to reorder tasks: ${errorMessage}`, { userId: (req as any).userId });
      res.status(500).json({ message: "Failed to reorder tasks", error: errorMessage });
    }
  });

  app.patch("/api/tasks/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      const userId = (req as any).userId;
      logger.info(`Task update request received for id: ${id}`, { updates });
      
      // Get the task before updating to check if it was completed (with user validation)
      const existingTask = await storage.getTask(id, userId);
      if (!existingTask) {
        logger.warn(`Failed to update task - not found or access denied: ${id}`, { userId });
        return res.status(404).json({ message: "Task not found" });
      }
      
      // Check if task belongs to user
      if (existingTask.userId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Special handling when completing a task: mark all checklist items as completed
      let finalUpdates = { ...updates };
      if (updates.completed === true && !existingTask.completed) {
        // Task is being completed - mark all checklist items as completed
        if (existingTask.checklistItems && existingTask.checklistItems.length > 0) {
          const completedChecklistItems = existingTask.checklistItems.map(item => ({
            ...item,
            completed: true
          }));
          finalUpdates.checklistItems = completedChecklistItems;
          logger.info(`Auto-completing ${completedChecklistItems.length} checklist items for completed task: ${id}`);
        }
      }
      
      const updatedTask = await storage.updateTask(id, finalUpdates);
      
      if (!updatedTask) {
        logger.warn(`Failed to update task - not found: ${id}`);
        return res.status(404).json({ message: "Task not found" });
      }
      
      // If task was just completed, record achievement progress
      if (!existingTask.completed && updatedTask.completed) {
        try {
          await storage.recordTaskCompletion(userId, updatedTask);
          logger.info(`Recorded task completion for achievements: ${id}`);
        } catch (achievementError) {
          logger.error(`Failed to record task completion for achievements: ${achievementError}`);
          // Don't fail the request if achievement recording fails
        }
      }
      
      logger.info(`Task updated successfully: ${id}`, { taskTitle: updatedTask.title });
      res.json(updatedTask);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to update task: ${errorMessage}`, { taskId: req.params.id });
      res.status(500).json({ message: "Failed to update task", error: errorMessage });
    }
  });

  // Update checklist items endpoint
  app.patch("/api/tasks/:id/checklist", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { checklistItems } = req.body;
      const userId = (req as any).userId;
      logger.info(`Checklist update request received for task: ${id}`);
      
      // Check if task exists and belongs to user
      const existingTask = await storage.getTask(id, userId);
      if (!existingTask) {
        logger.warn(`Failed to update checklist - task not found or access denied: ${id}`, { userId });
        return res.status(404).json({ message: "Task not found" });
      }
      
      if (existingTask.userId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Check if all checklist items are completed - if so, complete the main task too
      let finalUpdates: any = { checklistItems };
      if (checklistItems && checklistItems.length > 0) {
        const allItemsCompleted = checklistItems.every((item: any) => item.completed === true);
        if (allItemsCompleted && !existingTask.completed) {
          finalUpdates.completed = true;
          logger.info(`Auto-completing main task since all ${checklistItems.length} checklist items are completed: ${id}`);
        }
      }
      
      const updatedTask = await storage.updateTask(id, finalUpdates);
      
      if (!updatedTask) {
        logger.warn(`Failed to update checklist: ${id}`);
        return res.status(404).json({ message: "Task not found" });
      }
      
      logger.info(`Checklist updated successfully for task: ${id}`);
      res.json(updatedTask);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to update checklist: ${errorMessage}`, { taskId: req.params.id });
      res.status(500).json({ message: "Failed to update checklist", error: errorMessage });
    }
  });

  // Archive task endpoint
  app.patch("/api/tasks/:id/archive", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const userId = (req as any).userId;
      logger.info(`Task archive request received for id: ${id}`);
      
      // Check if task exists and belongs to user
      const existingTask = await storage.getTask(id, userId);
      if (!existingTask) {
        logger.warn(`Failed to archive task - not found or access denied: ${id}`, { userId });
        return res.status(404).json({ message: "Task not found" });
      }
      
      if (existingTask.userId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      if (!existingTask.completed) {
        return res.status(400).json({ message: "Only completed tasks can be archived" });
      }
      
      const success = await storage.archiveTask(id);
      if (!success) {
        logger.warn(`Failed to archive task: ${id}`);
        return res.status(500).json({ message: "Failed to archive task" });
      }
      
      logger.info(`Task archived successfully: ${id}`, { taskTitle: existingTask.title });
      res.json({ message: "Task archived successfully" });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to archive task: ${errorMessage}`, { taskId: req.params.id });
      res.status(500).json({ message: "Failed to archive task", error: errorMessage });
    }
  });

  // Get archived tasks endpoint
  app.get("/api/tasks/archived", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      logger.info(`Archived tasks request received for user: ${userId}`);
      
      const archivedTasks = await storage.getArchivedTasks(userId);
      
      logger.info(`Retrieved archived tasks successfully`, { 
        count: archivedTasks.length, 
        userId 
      });
      res.json(archivedTasks);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to get archived tasks: ${errorMessage}`, { userId: (req as any).userId });
      res.status(500).json({ message: "Failed to get archived tasks", error: errorMessage });
    }
  });

  app.delete("/api/tasks/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const userId = (req as any).userId;
      logger.info(`Task delete request received for id: ${id}`);
      
      // Check if task exists and belongs to user
      const task = await storage.getTask(id, userId);
      if (!task) {
        logger.warn(`Failed to delete task - not found or access denied: ${id}`, { userId });
        return res.status(404).json({ message: "Task not found" });
      }
      
      // Check if task belongs to user
      if (task.userId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Attempt to delete the task
      const success = await storage.deleteTask(id);
      
      if (!success) {
        logger.error(`Failed to delete task despite it existing: ${id}`);
        return res.status(500).json({ message: "Failed to delete task" });
      }
      
      logger.info(`Task deleted successfully: ${id}`);
      res.status(204).send();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Error deleting task: ${errorMessage}`, { taskId: req.params.id });
      res.status(500).json({ message: "Failed to delete task", error: errorMessage });
    }
  });

  // Task Sharing Routes
  app.post("/api/tasks/:id/share", async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { expirationHours = 24 } = req.body;
      
      // Find the task (public sharing doesn't require user validation)
      const task = await storage.getTask(id);
      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }
      
      // Create unique sharing ID
      const shareId = uuidv4();
      
      // Calculate expiration time
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + expirationHours);
      
      // Store shared task info in database
      await db.insert(sharedTasksTable).values({
        shareId,
        taskId: id,
        taskData: task,
        expiresAt
      });
      
      logger.info(`Task shared successfully`, { taskId: id, shareId });
      
      // Return sharing details
      res.status(201).json({
        shareId,
        shareUrl: `${req.protocol}://${req.get('host')}/share/${shareId}`,
        expiresAt
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to share task", { error: errorMessage });
      res.status(500).json({ message: "Failed to share task" });
    }
  });
  
  // Get shared task by share ID
  app.get("/api/share/:shareId", async (req: Request, res: Response) => {
    try {
      const { shareId } = req.params;
      logger.debug(`Retrieving shared task`, { shareId, reqPath: req.path, reqUrl: req.url });
      
      // Get shared task from database
      const [sharedTask] = await db.select()
        .from(sharedTasksTable)
        .where(eq(sharedTasksTable.shareId, shareId));
      
      if (!sharedTask) {
        logger.warn(`Shared task not found`, { shareId, reqPath: req.path });
        return res.status(404).json({ message: "Shared task not found or link has expired" });
      }
      
      logger.debug(`Found shared task`, { shareId, taskData: JSON.stringify(sharedTask).substring(0, 100) });
      
      // Check if expired
      const now = new Date();
      if (sharedTask.expiresAt < now) {
        // Delete expired shared task
        await db.delete(sharedTasksTable)
          .where(eq(sharedTasksTable.shareId, shareId));
          
        logger.warn(`Shared task link has expired`, { shareId });
        return res.status(410).json({ message: "Shared task link has expired" });
      }
      
      // Return the shared task
      res.json({
        task: sharedTask.taskData,
        expiresAt: sharedTask.expiresAt
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to retrieve shared task", { error: errorMessage, shareId: req.params.shareId });
      res.status(500).json({ message: "Failed to retrieve shared task" });
    }
  });
  
  // Import shared task
  app.post("/api/share/:shareId/import", async (req: Request, res: Response) => {
    try {
      const { shareId } = req.params;
      
      // Get shared task from database
      const [sharedTask] = await db.select()
        .from(sharedTasksTable)
        .where(eq(sharedTasksTable.shareId, shareId));
      
      if (!sharedTask) {
        logger.warn(`Shared task not found for import`, { shareId });
        return res.status(404).json({ message: "Shared task not found or link has expired" });
      }
      
      // Check if expired
      const now = new Date();
      if (sharedTask.expiresAt < now) {
        // Delete expired shared task
        await db.delete(sharedTasksTable)
          .where(eq(sharedTasksTable.shareId, shareId));
          
        logger.warn(`Shared task link has expired for import`, { shareId });
        return res.status(410).json({ message: "Shared task link has expired" });
      }
      
      // Create a new task based on the shared one
      // Reset completion status and give it a new ID
      const { id, ...taskDataWithoutId } = sharedTask.taskData;
      const taskToImport = {
        ...taskDataWithoutId,
        completed: false
      };
      
      // Create the new task
      const createdTask = await storage.createTask(taskToImport);
      
      logger.info(`Shared task imported successfully`, { shareId, newTaskId: createdTask.id });
      
      res.status(201).json(createdTask);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to import shared task", { error: errorMessage, shareId: req.params.shareId });
      res.status(500).json({ message: "Failed to import shared task" });
    }
  });

  // Direct Task Sharing Routes
  app.post("/api/tasks/:id/share-direct", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { email, message } = req.body;
      
      const currentUserId = (req as any).userId;
      
      // Find the task and verify ownership
      const task = await storage.getTask(id, currentUserId);
      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }
      
      // Find the target user
      const targetUser = await storage.getUserByUsernameOrEmail(email);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Don't allow sharing with yourself
      if (targetUser.id === currentUserId) {
        return res.status(400).json({ message: "Cannot share task with yourself" });
      }
      
      // Create the direct share
      const directShare = await storage.createDirectTaskShare({
        taskId: id,
        taskData: task,
        sharedByUserId: currentUserId,
        sharedWithUserId: targetUser.id,
        sharedWithUsername: targetUser.username,
      });
      
      logger.info(`Task shared directly with user`, { 
        taskId: id, 
        sharedWith: targetUser.username,
        shareId: directShare.id 
      });
      
      res.status(201).json({
        message: `Task shared with ${targetUser.username}`,
        shareId: directShare.id,
        sharedWith: targetUser.username
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to share task directly", { error: errorMessage });
      res.status(500).json({ message: "Failed to share task directly" });
    }
  });

  // Get direct task shares for current user
  app.get("/api/direct-shares", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUserId = (req as any).userId;
      
      const shares = await storage.getDirectTaskSharesForUser(currentUserId);
      res.json(shares);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get direct task shares", { error: errorMessage });
      res.status(500).json({ message: "Failed to get direct task shares" });
    }
  });

  // Accept a direct task share
  app.post("/api/direct-shares/:shareId/accept", requireAuth, async (req: Request, res: Response) => {
    try {
      const { shareId } = req.params;
      const currentUserId = (req as any).userId;
      
      const success = await storage.acceptDirectTaskShare(parseInt(shareId), currentUserId);
      
      if (!success) {
        return res.status(404).json({ message: "Direct share not found" });
      }
      
      logger.info(`Direct task share accepted`, { shareId, userId: currentUserId });
      res.json({ message: "Task share accepted" });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to accept direct task share", { error: errorMessage });
      res.status(500).json({ message: "Failed to accept direct task share" });
    }
  });

  // Import a direct task share
  app.post("/api/direct-shares/:shareId/import", requireAuth, async (req: Request, res: Response) => {
    try {
      const { shareId } = req.params;
      const currentUserId = (req as any).userId;
      
      const importedTask = await storage.importDirectTaskShare(parseInt(shareId), currentUserId);
      
      logger.info(`Direct task share imported`, { shareId, newTaskId: importedTask.id });
      res.status(201).json(importedTask);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to import direct task share", { error: errorMessage });
      res.status(500).json({ message: "Failed to import direct task share" });
    }
  });

  // User Timer Preferences Routes
  app.get("/api/user/timer-preferences", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUserId = (req as any).userId;
      const user = await storage.getUserById(currentUserId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      res.json({
        timerSound: user.timerSound || "Gentle Bell",
        alarmSound: user.alarmSound || "Gentle Bell",
        timerEnabled: user.timerEnabled ?? true,
        alarmEnabled: user.alarmEnabled ?? true
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get timer preferences", { error: errorMessage });
      res.status(500).json({ message: "Failed to get timer preferences" });
    }
  });

  app.put("/api/user/timer-preferences", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUserId = (req as any).userId;
      const { timerSound, alarmSound, timerEnabled, alarmEnabled } = req.body;
      
      await storage.updateUserTimerPreferences(currentUserId, {
        timerSound,
        alarmSound,
        timerEnabled,
        alarmEnabled
      });
      
      logger.info(`Timer preferences updated`, { 
        userId: currentUserId, 
        timerSound,
        alarmSound, 
        timerEnabled,
        alarmEnabled
      });
      
      res.json({ message: "Timer preferences updated" });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to update timer preferences", { error: errorMessage });
      res.status(500).json({ message: "Failed to update timer preferences" });
    }
  });

  // AI Task Parsing Route
  app.post("/api/ai/parse-tasks", async (req: Request, res: Response) => {
    try {
      const { transcript } = req.body;
      
      logger.info("Received task parsing request", { 
        transcript, 
        transcriptLength: transcript?.length || 0 
      });
      
      if (!transcript || typeof transcript !== 'string') {
        logger.warn("Invalid transcript provided for parsing", { transcript });
        return res.status(400).json({ message: "Invalid transcript provided" });
      }
      
      const tasks = await parseTasksFromTranscript(transcript);
      
      logger.info("Task parsing completed", { 
        originalTranscript: transcript,
        parsedTasks: tasks,
        taskCount: tasks.length 
      });
      
      res.json({ tasks });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to parse tasks from transcript", { 
        error: errorMessage,
        transcript: req.body.transcript 
      });
      res.status(500).json({ 
        message: "Failed to parse tasks",
        tasks: [req.body.transcript?.trim() || ""] // Fallback to original transcript
      });
    }
  });

  // AI Suggestions Routes
  app.post("/api/ai/suggestions", async (req: Request, res: Response) => {
    try {
      const { tasks } = req.body;
      const suggestions = await generateTaskSuggestions(tasks);
      res.json(suggestions);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to generate AI suggestions", { error: errorMessage });
      res.status(500).json({ 
        message: "Failed to generate suggestions",
        suggestions: [
          "Review weekly metrics",
          "Schedule team meeting",
          "Update project documents"
        ],
        insights: [
          "You're most productive between 9AM-11AM",
          "Work tasks completed faster with timers",
          "Consider 25min focus periods for better results"
        ]
      });
    }
  });

  // AIDOMO Chat Route with Calendar Task Creation
  app.post("/api/ai/chat", async (req: Request, res: Response) => {
    try {
      const { message, context, currentDate, selectedDate } = req.body;
      
      if (!message || typeof message !== 'string') {
        return res.status(400).json({ message: "Message is required" });
      }

      logger.info('AIDOMO chat request', { 
        messageLength: message.length, 
        context: context || 'general',
        currentDate,
        selectedDate
      });

      const isCalendarContext = context === 'calendar_task_creator';
      
      let systemPrompt = `You are AIDOMO â¨, the friendly AI assistant for AIChecklist.io, an ADHD-friendly task management platform. 

Your personality:
- Helpful, encouraging, and understanding
- ADHD-aware and neurodivergent-friendly
- Use emojis sparingly but meaningfully
- Keep responses concise but thorough
- Always supportive and non-judgmental

Your capabilities:
- Help with task management and organization
- Provide productivity tips for neurodivergent minds
- Suggest ADHD-friendly strategies
- Offer calendar and scheduling advice
- Support work-life balance`;

      if (isCalendarContext) {
        systemPrompt += `

ðï¸ CALENDAR MODE ACTIVE:
You can now CREATE TASKS directly in the user's calendar! When users ask for appointments, schedules, or tasks to be created, you MUST:

1. Be very specific about what you're creating: "I'm creating a [task name] on [date] at [time]"
2. Use concrete dates and times, not vague references
3. Encourage them about their planning efforts
4. Tell them exactly what to expect in their calendar

Context: Calendar Task Creator
Current Date: ${currentDate || 'Not specified'}
Selected Date: ${selectedDate || 'Not specified'}

IMPORTANT: When users request scheduling, be very explicit about the task details you're creating. For example:
- "I'm creating a 'Team Meeting' task for September 6th at 4:00 PM"
- "Adding 'Doctor Appointment' to your calendar for next Tuesday at 9:00 AM"

Guidelines:
- Always confirm the specific task name, date, and time you're creating
- Be encouraging about their organization efforts
- Keep responses under 250 words since you're also creating tasks`;
      }

      systemPrompt += `

Context: ${context || 'general_assistant'}

Guidelines:
- Keep responses under 500 words
- Use bullet points for clarity when helpful
- Acknowledge ADHD challenges positively
- Focus on practical, actionable advice
- Be encouraging about progress, however small`;

      // the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
      const response = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: message }
        ],
        max_tokens: 800,
        temperature: 0.7
      });

      const aiResponse = response.choices[0].message.content;
      
      let tasksToCreate = [];

      // If this is calendar context, try to extract task creation requests
      if (isCalendarContext) {
        try {
          const taskExtractionPrompt = `You are a task extraction specialist. Analyze this user message and extract any tasks/appointments they want to create.

User message: "${message}"
Current date: ${currentDate}
Selected date: ${selectedDate}

IMPORTANT: If the user is asking for ANY scheduling, appointment creation, or task addition, you MUST extract it as a task.

For each task, provide:
- title: The task/appointment name (be descriptive)
- category: Work, Personal, Health, Shopping, or Business
- priority: Low, Medium, or High
- scheduledDate: ISO date string (use selectedDate if specified, otherwise infer from message or use currentDate)
- scheduledTime: HH:MM format in 24-hour time (IMPORTANT: extract exact minutes if specified!)
- timer: Number of minutes if mentioned, empty string otherwise

Parse times VERY carefully:
- "3:55 PM" or "3:55pm" â "15:55" (NOT "15:00"!)
- "3 PM" or "3pm" â "15:00"
- "10:30 AM" or "10:30am" â "10:30"
- "2:45 PM" â "14:45"
- "noon" or "12pm" â "12:00"
- "midnight" â "00:00"
- If only hour is mentioned (like "3pm"), use :00 minutes
- If minutes are specified (like "3:55"), MUST preserve exact minutes

Parse dates intelligently:
- "tomorrow" = day after currentDate
- "next Friday" = next occurrence of Friday
- "September 6th" or "Sept 6" = 2025-09-06
- "the 6th" or "6th" = 6th of current month (September 2025) = 2025-09-06
- "the 5th" or "5th" = 5th of current month (September 2025) = 2025-09-05
- "Friday at 4pm" = next Friday at 16:00
- When only a day number is given (like "6th" or "the 6th"), assume current month (September 2025)

Examples that MUST create tasks:
- "Schedule a meeting tomorrow at 2pm" â [{"title":"Meeting","category":"Work","priority":"Medium","scheduledDate":"2025-09-05","scheduledTime":"14:00","timer":""}]
- "Appointment at 3:55 PM tomorrow" â [{"title":"Appointment","category":"Personal","priority":"Medium","scheduledDate":"2025-09-05","scheduledTime":"15:55","timer":""}]
- "Doctor visit Sept 6th at 10:30am" â [{"title":"Doctor visit","category":"Health","priority":"High","scheduledDate":"2025-09-06","scheduledTime":"10:30","timer":""}]
- "Put a scheduled event September 6th at 4 PM" â [{"title":"Scheduled Event","category":"Work","priority":"Medium","scheduledDate":"2025-09-06","scheduledTime":"16:00","timer":""}]
- "Meeting at 2:45 PM" â [{"title":"Meeting","category":"Work","priority":"Medium","scheduledDate":"2025-09-04","scheduledTime":"14:45","timer":""}]
- "Add doctor appointment next Tuesday" â [{"title":"Doctor Appointment","category":"Health","priority":"High","scheduledDate":"2025-09-10","scheduledTime":"09:00","timer":""}]

Return ONLY valid JSON array, no explanations or other text.`;

          const taskResponse = await openai.chat.completions.create({
            model: 'gpt-4o',
            messages: [
              { role: 'system', content: taskExtractionPrompt },
              { role: 'user', content: message }
            ],
            max_tokens: 1000,
            temperature: 0.1
          });

          const taskContent = taskResponse.choices[0].message.content?.trim();
          logger.info('Raw task extraction response', { 
            content: taskContent,
            messageLength: message.length,
            originalMessage: message 
          });
          
          if (taskContent) {
            // Try to find JSON in the response even if it doesn't start with [
            let jsonStart = taskContent.indexOf('[');
            let jsonEnd = taskContent.lastIndexOf(']');
            
            if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
              const jsonStr = taskContent.substring(jsonStart, jsonEnd + 1);
              try {
                tasksToCreate = JSON.parse(jsonStr);
                logger.info('Successfully extracted tasks for creation', { 
                  taskCount: tasksToCreate.length,
                  tasks: tasksToCreate.map(t => ({ title: t.title, category: t.category, scheduledDate: t.scheduledDate }))
                });
              } catch (parseError) {
                logger.warn('Failed to parse extracted JSON', { 
                  error: parseError.message,
                  jsonStr: jsonStr 
                });
              }
            } else {
              logger.warn('No valid JSON array found in task extraction response', { 
                content: taskContent 
              });
            }
          }
        } catch (error) {
          logger.error('Failed to extract tasks from message', { 
            error: error.message,
            stack: error.stack,
            message: message 
          });
          // Continue without task creation
        }
      }
      
      logger.info('AIDOMO chat response generated', { 
        responseLength: aiResponse?.length || 0,
        model: 'gpt-4o',
        tasksExtracted: tasksToCreate.length
      });

      res.json({ 
        response: aiResponse,
        tasks: tasksToCreate
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("AIDOMO chat error", { error: errorMessage });
      
      res.status(500).json({ 
        response: "I'm having trouble connecting right now, but I'm here to help! â¨ Try asking me about:\n\nâ¢ Task prioritization strategies\nâ¢ ADHD-friendly productivity tips\nâ¢ Calendar organization ideas\nâ¢ Breaking down overwhelming projects\n\nWhat would you like help with today?",
        tasks: []
      });
    }
  });

  // Logs Routes (for admin purposes)
  app.get("/api/logs", async (req: Request, res: Response) => {
    try {
      // Only allow access to logs in development mode
      if (process.env.NODE_ENV !== 'development') {
        return res.status(403).json({ message: "Logs access not allowed in production" });
      }
      
      const lines = req.query.lines ? parseInt(req.query.lines as string) : 100;
      const logs = logger.getAppLogs(lines);
      res.json({ logs });
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch logs" });
    }
  });

  app.get("/api/logs/errors", async (req: Request, res: Response) => {
    try {
      // Only allow access to logs in development mode
      if (process.env.NODE_ENV !== 'development') {
        return res.status(403).json({ message: "Logs access not allowed in production" });
      }
      
      const lines = req.query.lines ? parseInt(req.query.lines as string) : 100;
      const allLogs = logger.getErrorLogs(lines);
      
      // Filter logs to only show errors from the last hour
      const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
      const recentLogs = allLogs ? allLogs.split('\n').filter(log => {
        if (!log.trim()) return false;
        
        // Extract timestamp from log line (format: [2025-08-09 02:32:30])
        const timestampMatch = log.match(/\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\]/);
        if (!timestampMatch) return false;
        
        const logTime = new Date(timestampMatch[1]);
        return logTime > oneHourAgo;
      }).join('\n') : '';
      
      res.json({ logs: recentLogs });
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch error logs" });
    }
  });

  app.post("/api/logs/flush-all", async (req: Request, res: Response) => {
    try {
      // Only allow in development mode
      if (process.env.NODE_ENV !== 'development') {
        return res.status(403).json({ message: "Logs flush not allowed in production" });
      }
      
      logger.info('Flushing all system logs via logger interface');
      
      // Use logger's internal flush method if available, or just log that we're clearing
      if (typeof (logger as any).flush === 'function') {
        (logger as any).flush();
      }
      
      // Clear the error buffer by calling the logger's clear method if available
      if (typeof (logger as any).clearErrorBuffer === 'function') {
        (logger as any).clearErrorBuffer();
      }
      
      logger.info('All system logs flushed - system status reset to clean');
      
      res.json({ 
        message: "All logs flushed successfully",
        status: "clean",
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      logger.error('Failed to flush logs', { error });
      res.status(500).json({ message: "Failed to flush logs", details: error instanceof Error ? error.message : String(error) });
    }
  });
  
  // User Settings Routes
  app.get("/api/user/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const user = await storage.getCustomerById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      res.json(toUserSettings(user));
    } catch (error) {
      logger.error("Failed to get user settings", { error, userId: (req as any).userId });
      res.status(500).json({ message: "Failed to get user settings" });
    }
  });

  app.patch("/api/user/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      
      // Use the mapper to convert and validate
      const updateData = toUserUpdate(req.body);

      const [updatedUser] = await db.update(users)
        .set(updateData)
        .where(eq(users.id, userId))
        .returning();
      
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      logger.info(`User settings updated: ${userId}`, { updates: Object.keys(req.body) });
      
      res.json(toUserSettings(updatedUser));
    } catch (error) {
      // Check if it's a validation error from the mapper
      if (error instanceof Error && error.message.includes("Invalid autoArchiveHours")) {
        return res.status(400).json({ message: error.message });
      }
      
      logger.error("Failed to update user settings", { error, userId: (req as any).userId });
      res.status(500).json({ message: "Failed to update user settings" });
    }
  });

  // Admin authentication middleware for sensitive routes
  const requireAdminAuth = async (req: Request, res: Response, next: Function) => {
    const sessionId = req.headers.authorization?.replace('Bearer ', '');
    const userId = sessionId ? getUserIdFromSession(sessionId) : null;
    
    if (!userId) {
      return res.status(401).json({ message: "Authentication required" });
    }
    
    // Get user and check if they have admin privileges
    const user = await storage.getCustomerById(userId);
    if (!user || user.customerType !== 'admin') {
      logger.warn(`Unauthorized admin access attempt`, { userId, path: req.path });
      return res.status(403).json({ message: "Admin access required" });
    }
    
    (req as any).userId = userId;
    (req as any).user = user;
    next();
  };

  // Admin access verification endpoint
  app.post("/api/admin/verify-access", requireAdminAuth, async (req: Request, res: Response) => {
    try {
      const { password } = req.body;
      
      // Check if password matches environment variable
      const adminPassword = process.env.ADMIN_ACCESS_PASSWORD;
      if (!adminPassword) {
        logger.error("Admin access password not configured in environment variables");
        return res.status(500).json({ message: "Server configuration error" });
      }
      
      if (password !== adminPassword) {
        logger.warn(`Admin access denied - incorrect password`, { userId: (req as any).userId });
        return res.status(401).json({ message: "Incorrect password" });
      }
      
      logger.info(`Admin access granted for API management`, { userId: (req as any).userId });
      res.status(200).json({ message: "Access granted" });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Admin access verification failed", { error: errorMessage });
      res.status(500).json({ message: "Verification failed" });
    }
  });

  // API Keys Management Routes - PROTECTED with admin authentication
  app.get("/api/admin/keys", requireAdminAuth, async (req: Request, res: Response) => {
    try {
      logger.info(`Admin accessing API keys`, { userId: (req as any).userId });
      await getApiKeys(req, res);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to retrieve API keys", { error: errorMessage });
      res.status(500).json({ message: "Failed to retrieve API keys" });
    }
  });
  
  app.post("/api/admin/keys", requireAdminAuth, async (req: Request, res: Response) => {
    try {
      logger.info(`Admin updating API keys`, { userId: (req as any).userId });
      await saveApiKey(req, res);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to save API key", { error: errorMessage });
      res.status(500).json({ message: "Failed to save API key" });
    }
  });
  
  // Recurring Tasks Routes
  app.post("/api/recurring-tasks", requireAuth, async (req: Request, res: Response) => {
    try {
      const {
        title,
        category,
        priority,
        recurringFrequency,
        recurringInterval,
        nextDueDate,
        endDate,
        daysOfWeek,
        dayOfMonth,
        monthOfYear
      } = req.body;
      
      // Create the recurring task
      const task = await storage.createRecurringTask({
        title,
        category,
        priority,
        completed: false,
        timer: null,
        youtubeUrl: null,
        displayOrder: 0,
        scheduledDate: null,
        userId: (req as any).userId || 1, // Default to user 1 if not authenticated
        isRecurring: true,
        recurringFrequency,
        recurringInterval,
        nextDueDate: nextDueDate ? new Date(nextDueDate) : new Date(),
        endDate: endDate ? new Date(endDate) : null,
        daysOfWeek,
        dayOfMonth,
        monthOfYear,
        parentTaskId: null,
        // Archive fields
        archived: false,
        archivedAt: null,
        completedAt: null,
        checklistItems: []
      });
      
      logger.info(`Created recurring task: ${task.id}`, { 
        taskTitle: task.title,
        frequency: recurringFrequency,
        interval: recurringInterval
      });
      
      res.status(201).json(task);
    } catch (error) {
      logger.error("Failed to create recurring task", { error });
      res.status(500).json({ message: "Failed to create recurring task" });
    }
  });
  
  // Get all child tasks for a recurring task
  app.get("/api/recurring-tasks/:id/instances", async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      
      // Check if parent task exists
      const parentTask = await storage.getTask(id);
      if (!parentTask || !parentTask.isRecurring) {
        return res.status(404).json({ message: "Recurring task not found" });
      }
      
      // Get child tasks
      const childTasks = await storage.getChildTasks(id);
      
      res.status(200).json(childTasks);
    } catch (error) {
      logger.error("Failed to fetch recurring task instances", { error });
      res.status(500).json({ message: "Failed to fetch recurring task instances" });
    }
  });
  
  // Get download counter (public endpoint)
  app.get("/api/stats/downloads", async (req: Request, res: Response) => {
    try {
      const downloadStat = await storage.getAppStatistic('downloads');
      
      if (!downloadStat) {
        // Initialize to 500,000 if not exists
        const newStat = await storage.setAppStatistic('downloads', 500000);
        return res.json({ downloads: newStat.currentValue });
      }
      
      res.json({ downloads: downloadStat.currentValue });
    } catch (error) {
      logger.error("Failed to get download counter", { error });
      res.status(500).json({ message: "Failed to get download counter" });
    }
  });

  // Process due recurring tasks (can be called manually or by a scheduled job)
  app.post("/api/recurring-tasks/process", async (req: Request, res: Response) => {
    try {
      await storage.processRecurringTasks();
      res.status(200).json({ message: "Recurring tasks processed successfully" });
    } catch (error) {
      logger.error("Failed to process recurring tasks", { error });
      res.status(500).json({ message: "Failed to process recurring tasks" });
    }
  });

  // Achievement Routes
  app.get("/api/achievements", async (req: Request, res: Response) => {
    try {
      const achievements = await storage.getAllAchievements();
      res.json(achievements);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get achievements", { error: errorMessage });
      res.status(500).json({ message: "Failed to get achievements" });
    }
  });

  app.get("/api/user/achievements", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUserId = (req as any).userId;
      
      const userAchievements = await storage.getUserAchievements(currentUserId);
      res.json(userAchievements);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get user achievements", { error: errorMessage });
      res.status(500).json({ message: "Failed to get user achievements" });
    }
  });

  app.get("/api/user/stats", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUserId = (req as any).userId;
      
      const userStats = await storage.getUserStats(currentUserId);
      res.json(userStats);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get user stats", { error: errorMessage });
      res.status(500).json({ message: "Failed to get user stats" });
    }
  });


  
  app.post("/api/domoai/analyze-tasks", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      
      // Check if API key is configured
      if (!process.env.GEMINI_API_KEY) {
        return res.status(503).json({ 
          message: "AI service not configured. Please add GEMINI_API_KEY to enable this feature." 
        });
      }
      
      const tasks = await storage.getAllTasks(userId);
      const analysis = await analyzeTaskPatterns(tasks);
      res.json({ analysis });
    } catch (error) {
      logger.error("Task analysis error:", error);
      res.status(500).json({ message: "Failed to analyze tasks" });
    }
  });
  
  app.get("/api/domoai/suggestions", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      
      // Check if API key is configured
      if (!process.env.GEMINI_API_KEY) {
        return res.status(503).json({ 
          message: "AI service not configured. Please add GEMINI_API_KEY to enable this feature." 
        });
      }
      
      const tasks = await storage.getAllTasks(userId);
      const recentTasks = tasks.slice(0, 10); // Get last 10 tasks
      const suggestions = await generateTaskSuggestions(recentTasks);
      res.json({ suggestions });
    } catch (error) {
      logger.error("Task suggestion error:", error);
      res.status(500).json({ message: "Failed to generate suggestions" });
    }
  });
  
  app.get("/api/domoai/productivity-tips", requireAuth, async (req: Request, res: Response) => {
    try {
      // Check if API key is configured
      if (!process.env.GEMINI_API_KEY) {
        return res.status(503).json({ 
          message: "AI service not configured. Please add GEMINI_API_KEY to enable this feature." 
        });
      }
      
      const tips = await getProductivityTips();
      res.json({ tips });
    } catch (error) {
      logger.error("Productivity tips error:", error);
      res.status(500).json({ message: "Failed to get productivity tips" });
    }
  });

  // DomoAI Chat Routes - New OpenAI-powered chat system with comprehensive security
  app.post("/api/domoai/chat", 
    requireAuth, 
    createSecureDomoAIMiddleware(), 
    createAuditCompletionMiddleware(),
    async (req: Request, res: Response) => {
    try {
      const { messages, userMemory } = req.body;
      const userId = (req as any).userId;

      if (!messages || !Array.isArray(messages)) {
        await secureAuditLogger.logSecureRequest(
          userId,
          '/api/domoai/chat',
          'POST',
          'INVALID_REQUEST_FORMAT',
          400,
          req,
          'VALIDATION_ERROR'
        );
        return res.status(400).json({ message: "Messages array is required" });
      }

      // Log the start of the request (without sensitive data)
      await secureAuditLogger.logSecureRequest(
        userId,
        '/api/domoai/chat',
        'POST',
        { messageCount: messages.length, timestamp: new Date() },
        200,
        req
      );

      // ENHANCED SECURITY: Multi-layer validation
      const userAgent = req.headers['user-agent'] || '';
      const referer = req.headers['referer'] || '';
      
      // Strict origin validation
      const allowedDomains = [req.hostname, 'aichecklist.com', 'localhost'];
      if (referer && !allowedDomains.some(domain => referer.includes(domain))) {
        await secureAuditLogger.logSecureRequest(
          userId,
          '/api/domoai/chat',
          'POST',
          'INVALID_ORIGIN_BLOCKED',
          403,
          req,
          'SECURITY_VIOLATION'
        );
        
        logger.warn(`DomoAI unauthorized cross-origin access blocked`, { 
          userId, 
          referer, 
          userAgent,
          timestamp: new Date()
        });
        
        return res.status(403).json({ 
          message: "Access denied: Cross-origin requests not allowed",
          support: "Please access DomoAI directly from the AICHECKLIST application"
        });
      }

      // Enhanced suspicious pattern detection
      const messageText = messages.map(m => m.content).join(' ').toLowerCase();
      const suspiciousPatterns = [
        // Data access attempts
        'show me user data', 'list all users', 'give me passwords', 'database dump',
        'admin access', 'bypass security', 'export data', 'show all tasks',
        'other users', 'customer data', 'personal information', 'private data',
        
        // Injection attempts  
        'drop table', 'delete from', 'insert into', 'update set', 'select *',
        'union select', 'exec(', 'script>', 'eval(', 'function(',
        
        // System access
        'root access', 'sudo', 'administrator', 'system password', 'api key',
        'secret key', 'token', 'session id', 'auth bypass'
      ];
      
      const detectedPattern = suspiciousPatterns.find(pattern => messageText.includes(pattern));
      if (detectedPattern) {
        await secureAuditLogger.logSecureRequest(
          userId,
          '/api/domoai/chat',
          'POST',
          `SUSPICIOUS_PATTERN_DETECTED: ${detectedPattern}`,
          403,
          req,
          'SECURITY_VIOLATION'
        );
        
        logger.warn(`DomoAI security violation detected`, { 
          userId, 
          pattern: detectedPattern,
          messagePreview: messageText.substring(0, 50),
          timestamp: new Date()
        });
        
        return res.status(403).json({ 
          message: "I can only help with your personal tasks and productivity. I don't have access to system data or other users' information.",
          note: "If you need technical support, please contact AICHECKLIST staff directly."
        });
      }

      // Rate limiting check (enhanced)
      const requestKey = `domoai_${userId}_${Math.floor(Date.now() / 60000)}`; // Per minute
      // In production, implement Redis-based rate limiting

      const chatResult = await domoAI.chat(messages, userId, userMemory);
      const response = chatResult.response;
      const calendarConflicts = chatResult.calendarConflicts;
      
      // Check if calendar conflicts were detected
      if (calendarConflicts && calendarConflicts.hasConflicts) {
        return res.json({
          response,
          calendarConflicts: {
            conflicts: calendarConflicts.conflicts,
            proposals: calendarConflicts.proposals,
            targetDate: calendarConflicts.targetDate
          },
          conflictDetected: true
        });
      }
      
      // Check if response contains rolling tasks creation request
      if (response.includes('ROLLING_TASKS:')) {
        const rollingTasksMatch = response.match(/ROLLING_TASKS:\s*(\[[\s\S]*?\])/);
        if (rollingTasksMatch) {
          try {
            const tasksData = JSON.parse(rollingTasksMatch[1]);
            const createdTasks = await domoAI.createRollingTasksFromChat({ tasks: tasksData }, userId);
            
            // Log successful rolling tasks creation
            await secureAuditLogger.logSecureRequest(
              userId,
              '/api/domoai/chat',
              'POST',
              `ROLLING_TASKS_CREATED: ${createdTasks.length} tasks`,
              200,
              req
            );
            
            // Extract clean response without the ROLLING_TASKS JSON
            let cleanResponse = response.replace(/ROLLING_TASKS:\s*\[[\s\S]*?\]/, '').trim();
            
            // If no clean response, generate a success message
            if (!cleanResponse || cleanResponse.length < 10) {
              const taskList = createdTasks.map((t, i) => `${i + 1}. **${t.title}** - ${t.priority} Priority`).join('\n');
              cleanResponse = `Perfect! I've created all ${createdTasks.length} tasks with their respective priorities in your task list! \n\n${taskList}\n\nWhat else can I help you with? ð`;
            }
            
            return res.json({ 
              response: cleanResponse,
              taskCreated: true,
              task: createdTasks[0], // Return first task for notification
              totalTasksCreated: createdTasks.length
            });
          } catch (taskError) {
            await secureAuditLogger.logSecureRequest(
              userId,
              '/api/domoai/chat',
              'POST',
              'ROLLING_TASKS_CREATION_FAILED',
              500,
              req,
              'TASK_ERROR'
            );
            
            logger.error('Failed to create rolling tasks from chat:', taskError);
            return res.json({ 
              response: "I understand you want to create multiple tasks, but I had trouble processing them. Could you try describing them again?"
            });
          }
        }
      }
      
      // Check if response contains checklist creation request
      else if (response.includes('CREATE_CHECKLIST:')) {
        // Use a more robust pattern to extract the complete JSON
        const checklistMatch = response.match(/CREATE_CHECKLIST:\s*(\{[\s\S]*?\})\s*(?:\n|$)/);
        if (checklistMatch) {
          try {
            // Find the complete JSON object by properly matching braces
            const startPos = response.indexOf('CREATE_CHECKLIST:') + 'CREATE_CHECKLIST:'.length;
            const remainingText = response.substring(startPos).trim();
            
            let braceCount = 0;
            let inString = false;
            let escaped = false;
            let endIndex = -1;
            
            for (let i = 0; i < remainingText.length; i++) {
              const char = remainingText[i];
              
              if (escaped) {
                escaped = false;
                continue;
              }
              
              if (char === '\\') {
                escaped = true;
                continue;
              }
              
              if (char === '"') {
                inString = !inString;
                continue;
              }
              
              if (!inString) {
                if (char === '{') {
                  braceCount++;
                } else if (char === '}') {
                  braceCount--;
                  if (braceCount === 0) {
                    endIndex = i + 1;
                    break;
                  }
                }
              }
            }
            
            if (endIndex === -1) {
              throw new Error('Could not find complete JSON object');
            }
            
            const jsonStr = remainingText.substring(0, endIndex);
            const checklistData = JSON.parse(jsonStr);
            const createdChecklist = await domoAI.createChecklistFromChat(checklistData, userId);
            
            // Log successful checklist creation
            await secureAuditLogger.logSecureRequest(
              userId,
              '/api/domoai/chat',
              'POST',
              `CHECKLIST_CREATED: ${createdChecklist.title}`,
              200,
              req
            );
            
            // Extract clean response without the CREATE_CHECKLIST JSON
            let cleanResponse = response.replace(/CREATE_CHECKLIST:\s*{[\s\S]*?}(?=\s|$)/, '').trim();
            
            // If no clean response, generate a success message
            if (!cleanResponse || cleanResponse.length < 10) {
              const itemCount = createdChecklist.checklistItems.length;
              cleanResponse = `Perfect! I've created your **${createdChecklist.title}** checklist with ${itemCount} items in the ${createdChecklist.category} category!\n\nYou can find it in your Checklist tab. What else can I help you with? ð`;
            }
            
            return res.json({ 
              response: cleanResponse,
              checklistCreated: true,
              checklist: createdChecklist
            });
          } catch (checklistError) {
            await secureAuditLogger.logSecureRequest(
              userId,
              '/api/domoai/chat',
              'POST',
              'CHECKLIST_CREATION_FAILED',
              500,
              req,
              'CHECKLIST_ERROR'
            );
            
            logger.error('Failed to create checklist from chat:', checklistError);
            logger.error('Checklist data was:', checklistMatch ? checklistMatch[1] : 'No match found');
            logger.error('Full response was:', response);
            
            return res.json({ 
              response: "I understand you want to create a checklist, but I had trouble processing it. Could you try describing it again? Make sure to specify what items should be in your checklist."
            });
          }
        }
      }
      
      // Check if response contains template request (ADHD Super Hero List)
      else if (response.includes('TEMPLATE_REQUEST:')) {
        try {
          // Extract the template name from DomoAI's response
          const templateMatch = response.match(/TEMPLATE_REQUEST:\s*(.+)/);
          const requestedTemplate = templateMatch ? templateMatch[1].trim() : 'ADHD Daily Flow';
          
          // Apply the specific template requested by DomoAI
          const templateResult = await domoAI.applyADHDTemplate(requestedTemplate, userId);
          
          if (templateResult) {
            await secureAuditLogger.logSecureRequest(
              userId,
              '/api/domoai/chat',
              'POST',
              `ADHD_TEMPLATE_APPLIED: ${templateResult.templateName}`,
              200,
              req
            );
            
            // Extract the Super Hero List response from DomoAI's message
            const cleanResponse = response.replace(/TEMPLATE_REQUEST:\s*(.+)/, '').trim();
            
            // Handle different response types
            let successMessage;
            if (templateResult.appliedTemplates) {
              // Multiple templates applied
              successMessage = `ð **Amazing!** I've activated ALL ${templateResult.appliedTemplates.length} ADHD Super Hero templates for you! I've added ${templateResult.tasksCreated} power-up tasks to help you conquer any challenge!\n\nðª **Applied Templates:** ${templateResult.appliedTemplates.join(', ')}\n\nCheck your Task tab to see all your new Super Hero powers in action!`;
            } else {
              // Single template applied
              successMessage = `ð **Great news!** I've activated the "${templateResult.templateName}" template for you! I've added ${templateResult.tasksCreated} Super Hero tasks to help you conquer the day!\n\nCheck your Task tab to see your new power-ups in action!`;
            }
            
            const fullResponse = `${cleanResponse}\n\n${successMessage}`;
            
            return res.json({ 
              response: fullResponse,
              taskCreated: true,
              task: templateResult.tasks[0], // Return first task for notification
              totalTasksCreated: templateResult.tasksCreated,
              templateApplied: templateResult.templateName
            });
          } else {
            // Fallback if template application fails
            const cleanResponse = response.replace(/TEMPLATE_REQUEST:\s*(.+)/, '').trim();
            return res.json({ 
              response: cleanResponse
            });
          }
        } catch (templateError) {
          await secureAuditLogger.logSecureRequest(
            userId,
            '/api/domoai/chat',
            'POST',
            'TEMPLATE_APPLICATION_FAILED',
            500,
            req,
            'TEMPLATE_ERROR'
          );
          
          logger.error('Failed to apply ADHD template:', templateError);
          const cleanResponse = response.replace(/TEMPLATE_REQUEST:\s*(.+)/, '').trim();
          return res.json({ 
            response: cleanResponse
          });
        }
      }
      
      // Check if response contains high priority task request
      else if (response.includes('HIGH_PRIORITY_REQUEST: true')) {
        try {
          const highPriorityTasks = await domoAI.getHighPriorityTasks(userId);
          
          // Log secure access to high priority tasks
          await secureAuditLogger.logSecureRequest(
            userId,
            '/api/domoai/chat',
            'POST',
            `HIGH_PRIORITY_TASKS_ACCESSED: ${highPriorityTasks.length} tasks`,
            200,
            req
          );
          
          let taskResponse = "";
          if (highPriorityTasks.length === 0) {
            taskResponse = "Good news! You don't have any uncompleted high priority tasks right now. ð\n\nYou're staying on top of things! Is there anything else I can help you with?";
          } else {
            const taskList = highPriorityTasks.map((task, i) => 
              `${i + 1}. **${task.title}** - ${task.category}${task.timer ? ` (${task.timer} min timer)` : ''}${task.scheduledDate ? ` (due: ${task.scheduledDate})` : ''}`
            ).join('\n');
            
            taskResponse = `Here are your ${highPriorityTasks.length} high priority tasks that need attention:\n\n${taskList}\n\nThese are your most important items to focus on. Would you like help with any of these?`;
          }
          
          return res.json({ 
            response: taskResponse,
            highPriorityTasks: true,
            taskCount: highPriorityTasks.length
          });
        } catch (taskError) {
          await secureAuditLogger.logSecureRequest(
            userId,
            '/api/domoai/chat',
            'POST',
            'HIGH_PRIORITY_ACCESS_FAILED',
            500,
            req,
            'TASK_ERROR'
          );
          
          logger.error('Failed to access high priority tasks:', taskError);
          return res.json({ 
            response: "I can only help with what you share with me directly, and right now I don't have details on any high priority tasks in your current list. If you'd like, you can let me know about any high priority items you're working on and I'll be happy to help!"
          });
        }
      }
      
      // Check if response contains print request
      else if (response.includes('PRINT_REQUEST:')) {
        try {
          const printMatch = response.match(/PRINT_REQUEST:\s*(.+)/);
          const printRequest = printMatch ? printMatch[1].trim() : '';
          
          let printResult;
          
          // Handle conversation printing separately
          if (printRequest === 'conversation') {
            // Generate conversation print content
            const conversationHtml = `
              <div style="max-width: 800px; margin: 0 auto; font-family: Arial, sans-serif; line-height: 1.6;">
                <div style="text-align: center; border-bottom: 2px solid #333; padding-bottom: 20px; margin-bottom: 30px;">
                  <h1 style="color: #2563eb; margin-bottom: 10px;">AIDOMO Chat Conversation</h1>
                  <p style="color: #666; margin: 0;">AICHECKLIST.IO - Your AI-Powered Digital Majordomo</p>
                  <p style="color: #999; font-size: 14px; margin: 5px 0 0 0;">
                    Printed on ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}
                  </p>
                </div>
                
                <div style="space-y: 20px;">
                  ${messages.map((message, index) => `
                    <div style="margin-bottom: 20px; padding: 15px; border-radius: 8px; ${
                      message.role === 'user' 
                        ? 'background-color: #2563eb; color: white; margin-left: 20%;' 
                        : 'background-color: #f3f4f6; color: #333; margin-right: 20%;'
                    }">
                      <div style="font-weight: bold; font-size: 12px; text-transform: uppercase; margin-bottom: 8px; opacity: 0.8;">
                        ${message.role === 'user' ? 'You' : 'AIDOMO'}
                      </div>
                      <div style="white-space: pre-wrap;">${message.content}</div>
                      <div style="font-size: 11px; margin-top: 8px; opacity: 0.7;">
                        Message ${index + 1} of ${messages.length}
                      </div>
                    </div>
                  `).join('')}
                </div>
                
                <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #666; font-size: 12px;">
                  <p>Generated by AIDOMO - Your AI-Powered Digital Majordomo</p>
                  <p>AICHECKLIST.IO - Intelligent Task Management Platform</p>
                </div>
              </div>
            `;
            
            printResult = {
              success: true,
              title: 'AIDOMO Chat Conversation',
              content: conversationHtml
            };
          } else {
            // Handle other print requests through the printing service
            const { printingService } = await import('./printingService');
            printResult = await printingService.handlePrintRequest(printRequest, userId);
          }
          
          if (printResult.success) {
            await secureAuditLogger.logSecureRequest(
              userId,
              '/api/domoai/chat',
              'POST',
              `PRINT_REQUEST_PROCESSED: ${printRequest}`,
              200,
              req
            );
            
            const cleanResponse = response.replace(/PRINT_REQUEST:\s*(.+)/, '').trim();
            const printResponse = printRequest === 'conversation' 
              ? `${cleanResponse}\n\nð¨ï¸ **Excellent!** I've prepared your complete AIDOMO conversation for printing. The document includes all our messages with professional formatting and timestamps.\n\nYour conversation history is now ready for immediate printing with beautiful styling that captures our entire interaction.\n\nð What else can I help you accomplish today?`
              : `${cleanResponse}\n\nð¨ï¸ **Perfect!** I've prepared your professional print-ready document titled "${printResult.title}". The document has been formatted with beautiful styling and is ready for immediate printing.\n\nThe content is now available in your browser's print dialog. Simply use Ctrl+P (or Cmd+P on Mac) to print your professionally formatted document.\n\nð What else can I help you print or organize today?`;
            
            return res.json({ 
              response: printResponse,
              printGenerated: true,
              printContent: printResult.content,
              printTitle: printResult.title
            });
          } else {
            const cleanResponse = response.replace(/PRINT_REQUEST:\s*(.+)/, '').trim();
            return res.json({ 
              response: `${cleanResponse}\n\nI had trouble processing your print request. Could you be more specific about what you'd like me to print? I can print our conversation, todo lists, checklists, templates, and more!`
            });
          }
        } catch (printError) {
          await secureAuditLogger.logSecureRequest(
            userId,
            '/api/domoai/chat',
            'POST',
            'PRINT_REQUEST_FAILED',
            500,
            req,
            'PRINT_ERROR'
          );
          
          logger.error('Failed to process print request:', printError);
          const cleanResponse = response.replace(/PRINT_REQUEST:\s*(.+)/, '').trim();
          return res.json({ 
            response: `${cleanResponse}\n\nI'm having trouble with the printing service right now. Please try again in a moment.`
          });
        }
      }
      
      // Check if response contains single task creation request
      else if (response.includes('CREATE_TASK:')) {
        const taskDataMatch = response.match(/CREATE_TASK: ({.*?})/);
        if (taskDataMatch) {
          try {
            const taskData = JSON.parse(taskDataMatch[1]);
            const createdTask = await domoAI.createTaskFromChat(taskData, userId);
            
            // Log successful task creation
            await secureAuditLogger.logSecureRequest(
              userId,
              '/api/domoai/chat',
              'POST',
              `TASK_CREATED: ${createdTask.category}`,
              200,
              req
            );
            
            const successResponse = `Great! I've created that task for you: "${createdTask.title}" ð\n\nIt's been added to your ${createdTask.category} tasks with ${createdTask.priority} priority${createdTask.timer ? ` and a ${createdTask.timer}-minute timer` : ''}${createdTask.scheduledDate ? ` scheduled for ${createdTask.scheduledDate}` : ''}.\n\nWhat else can I help you with today?`;
            
            return res.json({ 
              response: successResponse,
              taskCreated: true,
              task: createdTask 
            });
          } catch (taskError) {
            await secureAuditLogger.logSecureRequest(
              userId,
              '/api/domoai/chat',
              'POST',
              'TASK_CREATION_FAILED',
              500,
              req,
              'TASK_ERROR'
            );
            
            logger.error('Failed to create task from chat:', taskError);
            return res.json({ 
              response: "I understand you want to create a task, but I had trouble processing it. Could you try describing it again?"
            });
          }
        }
      }

      // Log successful chat completion
      await secureAuditLogger.logSecureRequest(
        userId,
        '/api/domoai/chat',
        'POST',
        'CHAT_COMPLETED',
        200,
        req
      );

      res.json({ response, calendarConflicts: calendarConflicts || null });
    } catch (error) {
      // Log error
      await secureAuditLogger.logSecureRequest(
        (req as any).userId || 'unknown',
        '/api/domoai/chat',
        'POST',
        'CHAT_ERROR',
        500,
        req,
        'SYSTEM_ERROR'
      );
      
      logger.error("DomoAI chat error:", error);
      res.status(500).json({ message: "I'm having trouble right now. Please try again!" });
    }
  });

  // STAFF-ONLY: Secure audit log access endpoint
  app.get("/api/admin/audit-logs", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const user = await storage.getUserById(userId);
      
      // Only allow admin users to access audit logs
      if (!user || (user as any).role !== 'admin') {
        await secureAuditLogger.logSecureRequest(
          userId,
          '/api/admin/audit-logs',
          'GET',
          'UNAUTHORIZED_AUDIT_ACCESS',
          403,
          req,
          'SECURITY_VIOLATION'
        );
        
        return res.status(403).json({ 
          message: "Access denied: Administrator privileges required" 
        });
      }

      const staffKey = req.headers['x-staff-key'] as string;
      
      if (!staffKey) {
        return res.status(400).json({ 
          message: "Staff access key required",
          note: "Contact system administrator for audit log access"
        });
      }

      const filters = {
        userId: req.query.userId as string,
        endpoint: req.query.endpoint as string,
        dateFrom: req.query.dateFrom ? new Date(req.query.dateFrom as string) : undefined,
        dateTo: req.query.dateTo ? new Date(req.query.dateTo as string) : undefined,
        errorOnly: req.query.errorOnly === 'true'
      };

      const auditLogs = await secureAuditLogger.getAuditLogs(staffKey, filters);
      
      if (!auditLogs) {
        return res.status(403).json({ 
          message: "Invalid staff credentials" 
        });
      }

      // Log admin access to audit logs
      await secureAuditLogger.logSecureRequest(
        userId,
        '/api/admin/audit-logs',
        'GET',
        'AUDIT_LOG_ACCESS_GRANTED',
        200,
        req
      );

      res.json({ 
        success: true, 
        logs: auditLogs,
        note: "Customer data is encrypted and accessible only to authorized AICHECKLIST staff"
      });

    } catch (error) {
      logger.error("Audit log access error:", error);
      res.status(500).json({ message: "Failed to retrieve audit logs" });
    }
  });

  app.get("/api/domoai/analyze", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const analysis = await domoAI.analyzeTasks(userId);
      res.json({ analysis });
    } catch (error) {
      logger.error("DomoAI task analysis error:", error);
      res.status(500).json({ message: "Failed to analyze tasks" });
    }
  });

  app.get("/api/domoai/tips", requireAuth, async (req: Request, res: Response) => {
    try {
      // Prevent caching to ensure fresh tips
      res.set({
        'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0',
        'Surrogate-Control': 'no-store'
      });
      
      const tips = await domoAI.getProductivityTips();
      res.json({ tips });
    } catch (error) {
      logger.error("DomoAI productivity tips error:", error);
      res.status(500).json({ message: "Failed to get productivity tips" });
    }
  });

  // DomoAI Voice Status endpoint - check voice feature access
  app.get("/api/domoai/voice-status", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const user = await storage.getCustomerById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Check if user is enterprise
      const isEnterprise = user.subscriptionPlan === 'enterprise' || user.customerType === 'enterprise';
      
      // For enterprise accounts, voice is always enabled
      if (isEnterprise) {
        return res.json({
          enabled: true,
          isEnterprise: true,
          trialDaysLeft: null,
          message: "Voice features enabled for enterprise account"
        });
      }

      // For demo/free accounts, check trial status
      const now = new Date();
      let trialStartDate = user.voiceTrialStartDate;
      
      // If no trial start date, this is first use - start the trial
      if (!trialStartDate) {
        await storage.updateCustomer(userId, {
          voiceTrialStartDate: now,
          voiceTrialActive: true
        });
        trialStartDate = now;
      }

      // Calculate days since trial started
      const trialDays = 7; // One week trial
      const daysSinceStart = Math.floor((now.getTime() - new Date(trialStartDate).getTime()) / (1000 * 60 * 60 * 24));
      const daysLeft = Math.max(0, trialDays - daysSinceStart);
      
      // Check if trial has expired
      const trialExpired = daysSinceStart >= trialDays;
      
      // Update trial status if expired
      if (trialExpired && user.voiceTrialActive) {
        await storage.updateCustomer(userId, {
          voiceTrialActive: false
        });
      }

      return res.json({
        enabled: !trialExpired,
        isEnterprise: false,
        trialDaysLeft: trialExpired ? 0 : daysLeft,
        message: trialExpired 
          ? "Voice trial expired. Upgrade to Enterprise to continue using voice features."
          : `Voice trial active. ${daysLeft} days remaining.`
      });
      
    } catch (error) {
      logger.error("Voice status check error:", error);
      res.status(500).json({ message: "Failed to check voice status" });
    }
  });

  // Get current authenticated user
  app.get("/api/auth/user", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUserId = (req as any).userId;
      
      // Get user from database by ID using storage interface
      const user = await storage.getCustomerById(currentUserId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Return user data without sensitive information
      const { password: _, voicePassword: __, ...userResponse } = user;
      
      res.json(userResponse);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get current user", { error: errorMessage });
      res.status(500).json({ message: "Failed to get user data" });
    }
  });

  // Profile update route
  app.patch("/api/user/profile", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUserId = (req as any).userId;
      const { fullName, companyName, address, profilePictureUrl } = req.body;
      
      // Validate input
      const profileData: Partial<User> = {};
      if (fullName !== undefined) profileData.fullName = fullName;
      if (companyName !== undefined) profileData.companyName = companyName; 
      if (address !== undefined) profileData.address = address;
      if (profilePictureUrl !== undefined) profileData.profilePictureUrl = profilePictureUrl;
      
      const updatedUser = await storage.updateUserProfile(currentUserId, profileData);
      
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Return user data without sensitive information
      const { password: _, voicePassword: __, ...userResponse } = updatedUser;
      
      logger.info(`Profile updated for user: ${currentUserId}`, { 
        updates: Object.keys(profileData)
      });
      
      res.json(userResponse);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to update user profile", { error: errorMessage });
      res.status(500).json({ message: "Failed to update profile" });
    }
  });

  // Subscription Routes
  app.get("/api/subscription-plans", async (req: Request, res: Response) => {
    try {
      const plans = await db.select()
        .from(subscriptionPlans)
        .where(eq(subscriptionPlans.isActive, true))
        .orderBy(subscriptionPlans.price);

      res.status(200).json({
        success: true,
        plans
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error('Failed to get subscription plans', { error: errorMessage });
      
      res.status(500).json({ 
        success: false,
        message: 'Failed to get subscription plans. Please try again later.',
        error: errorMessage
      });
    }
  });

  app.post("/api/subscriptions/trial", async (req: Request, res: Response) => {
    try {
      const { planId, userId = 1 } = req.body; // Default to user ID 1 for demo purposes
      
      // In a real app, you would get the user ID from the authenticated session
      
      // Start a plan-specific free trial for the user
      const result = await startFreeTrial(userId, planId);
      
      logger.info('Started plan-specific free trial', { 
        userId, 
        planId: planId || 'free', 
        trialDays: result.trialDays 
      });
      
      res.status(200).json({
        success: true,
        trialEndsAt: result.trialEndsAt,
        trialDays: result.trialDays,
        message: `Your ${result.trialDays}-day free trial has been started successfully`
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error('Failed to start free trial', { error: errorMessage });
      
      // Create a more graceful error response
      res.status(500).json({ 
        success: false,
        message: 'Failed to start free trial. Please try again later.',
        error: errorMessage
      });
    }
  });
  
  app.post("/api/subscriptions", async (req: Request, res: Response) => {
    try {
      const { planId, userId = 1 } = req.body; // Default to user ID 1 for demo purposes
      
      // In a real app, you would get the user ID from the authenticated session
      
      // Create a subscription with Stripe
      const subscription = await createSubscription(userId, planId);
      
      res.status(200).json({
        success: true,
        subscriptionId: subscription.subscriptionId,
        clientSecret: subscription.clientSecret
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error('Failed to create subscription', { error: errorMessage });
      
      // Create a more descriptive error response
      let userMessage = 'Failed to create subscription. Please try again later.';
      let statusCode = 500;
      
      // Handle common errors
      if (errorMessage.includes('not found')) {
        statusCode = 404;
        userMessage = errorMessage;
      } else if (errorMessage.includes('Price ID')) {
        statusCode = 400; 
        userMessage = 'Invalid subscription plan selected.';
      }
      
      res.status(statusCode).json({ 
        success: false,
        message: userMessage,
        error: errorMessage
      });
    }
  });
  
  app.get("/api/subscriptions/status", async (req: Request, res: Response) => {
    try {
      const userId = req.query.userId as string || '1'; // Default to user ID 1 for demo purposes
      
      // In a real app, you would get the user ID from the authenticated session
      
      // Get the user's subscription status
      const status = await getUserSubscription(parseInt(userId));
      
      res.status(200).json({
        success: true,
        ...status
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error('Failed to get subscription status', { error: errorMessage });
      
      // Return a useful status even in case of error
      res.status(200).json({ 
        success: false,
        status: 'unknown',
        message: 'Could not retrieve subscription status',
        error: errorMessage
      });
    }
  });
  
  app.post("/api/subscriptions/cancel", async (req: Request, res: Response) => {
    try {
      const { userId = 1 } = req.body; // Default to user ID 1 for demo purposes
      
      // In a real app, you would get the user ID from the authenticated session
      
      // Cancel the subscription with Stripe
      const result = await cancelSubscription(userId);
      
      res.status(200).json({
        success: true,
        message: 'Your subscription has been canceled and will end at the current billing period'
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error('Failed to cancel subscription', { error: errorMessage });
      
      let userMessage = 'Failed to cancel subscription. Please try again later.';
      let statusCode = 500;
      
      // Handle specific errors
      if (errorMessage.includes('not found') || errorMessage.includes('no subscription')) {
        statusCode = 404;
        userMessage = 'No active subscription found to cancel.';
      }
      
      res.status(statusCode).json({ 
        success: false,
        message: userMessage,
        error: errorMessage
      });
    }
  });

  // Feedback Routes
  app.post("/api/feedback", async (req: Request, res: Response) => {
    try {
      const validatedData = insertFeedbackSchema.parse(req.body);
      
      const feedback = await storage.createFeedback(validatedData);
      
      logger.info(`Feedback submitted: ${feedback.subject}`, { 
        feedbackId: feedback.id,
        category: feedback.category,
        rating: feedback.rating 
      });
      
      res.status(201).json({
        success: true,
        message: "Thank you for your feedback! We'll review it and get back to you soon.",
        feedbackId: feedback.id
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to submit feedback", { error: errorMessage });
      
      res.status(500).json({ 
        success: false,
        message: "Failed to submit feedback. Please try again later.",
        error: errorMessage 
      });
    }
  });

  // Get all feedback (admin only - for future use)
  app.get("/api/feedback", async (req: Request, res: Response) => {
    try {
      const allFeedback = await storage.getAllFeedback();
      
      res.status(200).json(allFeedback);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to retrieve feedback", { error: errorMessage });
      
      res.status(500).json({ 
        message: "Failed to retrieve feedback",
        error: errorMessage 
      });
    }
  });

  // Customer Management API Routes
  app.get("/api/customers", async (req: Request, res: Response) => {
    try {
      // TODO: Add admin authentication check
      const customers = await storage.getAllCustomers();
      res.json(customers);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get customers", { error: errorMessage });
      res.status(500).json({ message: "Failed to get customers" });
    }
  });

  app.get("/api/customers/:id", async (req: Request, res: Response) => {
    try {
      const customerId = parseInt(req.params.id);
      const customer = await storage.getCustomerById(customerId);
      
      if (!customer) {
        return res.status(404).json({ message: "Customer not found" });
      }
      
      res.json(customer);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get customer", { error: errorMessage });
      res.status(500).json({ message: "Failed to get customer" });
    }
  });

  app.put("/api/customers/:id", async (req: Request, res: Response) => {
    try {
      const customerId = parseInt(req.params.id);
      const updates = req.body;
      
      const updatedCustomer = await storage.updateCustomer(customerId, updates);
      
      if (!updatedCustomer) {
        return res.status(404).json({ message: "Customer not found" });
      }
      
      res.json(updatedCustomer);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to update customer", { error: errorMessage });
      res.status(500).json({ message: "Failed to update customer" });
    }
  });

  app.get("/api/customers/:id/analytics", async (req: Request, res: Response) => {
    try {
      const customerId = parseInt(req.params.id);
      const analytics = await storage.getCustomerAnalytics(customerId);
      res.json(analytics);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get customer analytics", { error: errorMessage });
      res.status(500).json({ message: "Failed to get customer analytics" });
    }
  });

  app.post("/api/customers/:id/events", async (req: Request, res: Response) => {
    try {
      const customerId = parseInt(req.params.id);
      const eventData = {
        ...req.body,
        userId: customerId,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        platform: req.get('User-Agent')?.includes('Mobile') ? 'mobile' : 'web'
      };
      
      const event = await storage.recordCustomerEvent(eventData);
      res.json(event);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to record customer event", { error: errorMessage });
      res.status(500).json({ message: "Failed to record customer event" });
    }
  });

  app.get("/api/customers/status/:status", async (req: Request, res: Response) => {
    try {
      const status = req.params.status;
      const customers = await storage.getCustomersByStatus(status);
      res.json(customers);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get customers by status", { error: errorMessage });
      res.status(500).json({ message: "Failed to get customers by status" });
    }
  });

  app.get("/api/customers/subscription/:status", async (req: Request, res: Response) => {
    try {
      const subscriptionStatus = req.params.status;
      const customers = await storage.getCustomersBySubscriptionStatus(subscriptionStatus);
      res.json(customers);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get customers by subscription status", { error: errorMessage });
      res.status(500).json({ message: "Failed to get customers by subscription status" });
    }
  });

  app.get("/api/customers/search", async (req: Request, res: Response) => {
    try {
      const query = req.query.q as string;
      if (!query) {
        return res.status(400).json({ message: "Search query is required" });
      }
      
      const customers = await storage.searchCustomers(query);
      res.json(customers);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to search customers", { error: errorMessage });
      res.status(500).json({ message: "Failed to search customers" });
    }
  });

  // Timer Analytics Routes
  app.post("/api/timer/record-session", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const sessionData = req.body;
      
      // Validate required fields
      if (!sessionData.timerType || !sessionData.durationMinutes) {
        return res.status(400).json({ 
          message: "Timer type and duration are required" 
        });
      }
      
      // Calculate early completion percentage if completed early
      let earlyCompletionPercentage = null;
      if (sessionData.completedEarly && sessionData.actualMinutes && sessionData.durationMinutes) {
        earlyCompletionPercentage = Math.round(
          ((sessionData.durationMinutes - sessionData.actualMinutes) / sessionData.durationMinutes) * 100
        );
      }
      
      const analyticsData = {
        userId,
        timerType: sessionData.timerType,
        durationMinutes: sessionData.durationMinutes,
        actualMinutes: sessionData.actualMinutes || sessionData.durationMinutes,
        completedEarly: sessionData.completedEarly || false,
        earlyCompletionPercentage,
        taskTitle: sessionData.taskTitle || null,
        startedAt: sessionData.startedAt ? new Date(sessionData.startedAt) : new Date(),
        completedAt: new Date()
      };
      
      const session = await storage.recordTimerSession(analyticsData);
      
      logger.info("Timer session recorded", { 
        userId, 
        timerType: sessionData.timerType,
        completedEarly: sessionData.completedEarly,
        sessionId: session.id 
      });
      
      res.status(201).json({
        success: true,
        message: "Timer session recorded successfully",
        session
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to record timer session", { error: errorMessage });
      res.status(500).json({ 
        message: "Failed to record timer session",
        error: errorMessage 
      });
    }
  });

  app.get("/api/timer/analytics", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const days = parseInt(req.query.days as string) || 30;
      
      const analytics = await storage.getUserTimerAnalytics(userId, days);
      
      res.json({
        success: true,
        analytics,
        period: `${days} days`,
        totalSessions: analytics.length
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get timer analytics", { error: errorMessage });
      res.status(500).json({ 
        message: "Failed to get timer analytics",
        error: errorMessage 
      });
    }
  });

  app.get("/api/timer/productivity-stats", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      
      const productivityStats = await storage.getProductivityStats(userId);
      
      res.json({
        success: true,
        ...productivityStats,
        insights: {
          improvementRate: productivityStats.earlyCompletions > 0 
            ? `${Math.round((productivityStats.earlyCompletions / productivityStats.totalSessions) * 100)}% of sessions completed early`
            : "No early completions yet",
          efficiency: productivityStats.averageEarlyPercentage > 0
            ? `Average ${productivityStats.averageEarlyPercentage}% time saved when completing early`
            : "Efficiency data not available",
          trend: productivityStats.productivityTrend
        }
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("Failed to get productivity stats", { error: errorMessage });
      res.status(500).json({ 
        message: "Failed to get productivity stats",
        error: errorMessage 
      });
    }
  });

  // Chart and achievement sharing routes (mixed auth - some routes public, some protected)
  app.use('/api/shares', sharesRouter);
  app.use('/api/video', videoRouter);
  app.use('/api/user/preferences', requireAuth, preferencesRouter);

  // User Memory Management Routes for AI Context
  app.get('/api/user/memory', requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const userMemory = await storage.getUserMemory(userId);
      
      if (!userMemory) {
        // Return default memory structure if none exists
        return res.json({
          preferredName: null,
          personalDetails: {},
          recentConversations: [],
          userPreferences: {},
          productivityInsights: {}
        });
      }
      
      res.json(userMemory);
    } catch (error) {
      logger.error('Error fetching user memory:', error);
      res.status(500).json({ message: 'Failed to fetch user memory' });
    }
  });

  app.post('/api/user/memory', requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const memoryData = req.body;
      
      const updatedMemory = await storage.saveUserMemory(userId, memoryData);
      res.json(updatedMemory);
    } catch (error) {
      logger.error('Error saving user memory:', error);
      res.status(500).json({ message: 'Failed to save user memory' });
    }
  });

  app.put('/api/user/memory/conversation', requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { topic, summary, keyPoints, userMood, taskContext } = req.body;
      
      const conversationEntry = {
        timestamp: new Date().toISOString(),
        topic,
        summary,
        keyPoints: keyPoints || [],
        userMood,
        taskContext
      };
      
      await storage.addConversationToMemory(userId, conversationEntry);
      res.json({ success: true });
    } catch (error) {
      logger.error('Error adding conversation to memory:', error);
      res.status(500).json({ message: 'Failed to save conversation' });
    }
  });

  app.put('/api/user/memory/name', requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { preferredName } = req.body;
      
      await storage.updateUserMemoryField(userId, 'preferredName', preferredName);
      res.json({ success: true });
    } catch (error) {
      logger.error('Error updating preferred name:', error);
      res.status(500).json({ message: 'Failed to update preferred name' });
    }
  });

  // Bulk Export/Import Routes
  app.get('/api/tasks/export', requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const format = req.query.format as string || 'json';
      
      const userTasks = await storage.getAllTasks(userId);
      
      if (format === 'csv') {
        // Convert tasks to CSV format
        const csvHeaders = ['Title', 'Description', 'Category', 'Priority', 'Status', 'Created Date', 'Due Date', 'Completed Date'];
        const csvRows = userTasks.map(task => [
          `"${task.title.replace(/"/g, '""')}"`,
          `""`,  // description field doesn't exist
          `"${task.category}"`,
          `"${task.priority}"`,
          `"${task.completed ? 'Completed' : 'Pending'}"`,
          `"${task.createdAt?.toISOString() || ''}"`,
          `"${task.scheduledDate?.toISOString() || ''}"`,
          `"${task.completedAt?.toISOString() || ''}"`
        ]);
        
        const csvContent = [csvHeaders.join(','), ...csvRows.map(row => row.join(','))].join('\n');
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', 'attachment; filename="aichecklist_tasks.csv"');
        res.send(csvContent);
      } else {
        // JSON format
        const exportData = {
          exportDate: new Date().toISOString(),
          source: 'AICHECKLIST',
          version: '1.0',
          totalTasks: userTasks.length,
          tasks: userTasks.map(task => ({
            title: task.title,
            // description field doesn't exist on Task type
            category: task.category,
            priority: task.priority,
            completed: task.completed,
            createdAt: task.createdAt,
            scheduledDate: task.scheduledDate,
            completedAt: task.completedAt,
            timer: task.timer,
            isRecurring: task.isRecurring
          }))
        };
        
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', 'attachment; filename="aichecklist_tasks.json"');
        res.json(exportData);
      }
    } catch (error) {
      handleRouteError(error, req, res, 'Export tasks');
    }
  });

  app.post('/api/tasks/import', requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { tasks, format } = req.body;
      
      if (!tasks || !Array.isArray(tasks)) {
        return res.status(400).json({ message: 'Invalid tasks data' });
      }
      
      let importedCount = 0;
      let skippedCount = 0;
      const errors: string[] = [];
      
      for (const taskData of tasks) {
        try {
          // Validate and sanitize task data
          const validatedTask = {
            title: String(taskData.title || '').trim(),
            description: String(taskData.description || '').trim(),
            category: String(taskData.category || 'Personal').trim(),
            priority: ['Low', 'Medium', 'High'].includes(taskData.priority) ? taskData.priority : 'Medium',
            completed: Boolean(taskData.completed),
            dueDate: taskData.dueDate ? new Date(taskData.dueDate) : null,
            timer: taskData.timer ? Number(taskData.timer) : null,
            recurring: taskData.recurring || null
          };
          
          if (!validatedTask.title) {
            skippedCount++;
            errors.push(`Skipped task with empty title`);
            continue;
          }
          
          await storage.createTask(userId, validatedTask);
          importedCount++;
        } catch (taskError) {
          skippedCount++;
          errors.push(`Failed to import task "${taskData.title}": ${taskError instanceof Error ? taskError.message : 'Unknown error'}`);
        }
      }
      
      res.json({ 
        message: `Import completed: ${importedCount} tasks imported, ${skippedCount} skipped`,
        imported: importedCount,
        skipped: skippedCount,
        errors: errors.slice(0, 10) // Limit error messages
      });
    } catch (error) {
      handleRouteError(error, req, res, 'Import tasks');
    }
  });

  // Notification routes
  app.get('/api/notifications', requireAuth, async (req, res) => {
    try {
      const userId = (req as any).userId;
      const includeRead = req.query.includeRead === 'true';
      
      const userNotifications = await notificationService.getUserNotifications(userId, includeRead);
      
      res.json(userNotifications);
    } catch (error) {
      logger.error('Error fetching notifications', { error, userId: (req as any).userId });
      res.status(500).json({ message: 'Failed to fetch notifications' });
    }
  });

  app.put('/api/notifications/:id/read', requireAuth, async (req, res) => {
    try {
      const userId = (req as any).userId;
      const notificationId = parseInt(req.params.id);
      
      await notificationService.markAsRead(notificationId, userId);
      
      res.json({ success: true });
    } catch (error) {
      logger.error('Error marking notification as read', { error, notificationId: req.params.id, userId: (req as any).userId });
      res.status(500).json({ message: 'Failed to mark notification as read' });
    }
  });

  // Trigger calendar reminders manually (for testing)
  app.post('/api/notifications/calendar-reminders', requireAuth, async (req, res) => {
    try {
      const remindersCreated = await notificationService.createCalendarReminders();
      
      res.json({ 
        success: true, 
        remindersCreated,
        message: `Created ${remindersCreated} calendar reminders` 
      });
    } catch (error) {
      logger.error('Error creating calendar reminders', { error });
      res.status(500).json({ message: 'Failed to create calendar reminders' });
    }
  });

  // User preferences routes (for achievement and data collection settings)
  app.get('/api/user/preferences', requireAuth, async (req, res) => {
    try {
      const userId = (req as any).userId;
      const user = await storage.getCustomerById(userId);
      
      if (!user) {
        return res.status(404).json({ message: 'User not found' });
      }
      
      // Return user preferences for achievements and data collection
      const preferences = {
        achievementsEnabled: user.achievementsEnabled ?? true,
        dataCollectionConsent: user.dataCollectionConsent ?? false,
      };
      
      res.json(preferences);
    } catch (error) {
      logger.error('Error fetching user preferences', { error, userId: (req as any).userId });
      res.status(500).json({ message: 'Failed to fetch user preferences' });
    }
  });

  app.patch('/api/user/preferences', requireAuth, async (req, res) => {
    try {
      const userId = (req as any).userId;
      const { achievementsEnabled, dataCollectionConsent } = req.body;
      
      // Update user preferences
      const updateData: any = {
        updatedAt: new Date()
      };
      
      if (achievementsEnabled !== undefined) {
        updateData.achievementsEnabled = achievementsEnabled;
      }
      if (dataCollectionConsent !== undefined) {
        updateData.dataCollectionConsent = dataCollectionConsent;
      }

      const [updatedUser] = await db.update(users)
        .set(updateData)
        .where(eq(users.id, userId))
        .returning();
      
      if (!updatedUser) {
        return res.status(404).json({ message: 'User not found' });
      }
      
      logger.info('User preferences updated successfully', { 
        userId, 
        achievementsEnabled: updatedUser.achievementsEnabled,
        dataCollectionConsent: updatedUser.dataCollectionConsent 
      });
      
      res.json({ 
        success: true,
        achievementsEnabled: updatedUser.achievementsEnabled,
        dataCollectionConsent: updatedUser.dataCollectionConsent
      });
    } catch (error) {
      logger.error('Error updating user preferences', { error, userId: (req as any).userId });
      res.status(500).json({ message: 'Failed to update user preferences' });
    }
  });

  // Template routes - maintaining clean, professional design
  app.get('/api/templates', async (req: Request, res: Response) => {
    try {
      const templates = await storage.getTemplates();
      res.json(templates);
    } catch (error) {
      handleRouteError(error, req, res, "Get templates");
    }
  });

  app.post('/api/templates/use/:id', requireAuth, async (req: Request, res: Response) => {
    try {
      const templateId = parseInt(req.params.id);
      const userId = (req as any).userId;
      const { mode = "template" } = req.body; // Default to template mode
      
      const template = await storage.getTemplate(templateId);
      if (!template) {
        return res.status(404).json({ message: "Template not found" });
      }

      let createdTasks = [];
      
      if (mode === "checklist") {
        // Create ONE task with all template items as checklist items
        const checklistItems = template.tasks.map((templateTask: any, index: number) => ({
          id: `item_${Date.now()}_${index}`,
          text: templateTask.title,
          completed: false
        }));
        
        // Use the first task's properties for the main task, or sensible defaults
        const firstTask: any = template.tasks[0] || {};
        const scheduledDate = firstTask.scheduledDaysFromNow 
          ? new Date(Date.now() + firstTask.scheduledDaysFromNow * 24 * 60 * 60 * 1000)
          : null;
        
        const mainTask = await storage.createTask({
          title: `${template.name} Checklist`,
          category: firstTask.category || "Personal",
          priority: firstTask.priority || "Medium",
          userId: userId,
          completed: false,
          timer: firstTask.timer || null,
          youtubeUrl: null,
          scheduledDate: scheduledDate,
          isRecurring: false,
          recurringFrequency: null,
          recurringInterval: null,
          parentTaskId: null,
          checklistItems: checklistItems,
          displayOrder: 0,
          completedAt: null,
          nextDueDate: null,
          endDate: null,
          daysOfWeek: null,
          dayOfMonth: null,
          monthOfYear: null,
          archived: false,
          archivedAt: null
        });
        
        createdTasks.push(mainTask);
        
      } else {
        // Original behavior: Create separate tasks for each template item
        for (const templateTask of template.tasks) {
          const scheduledDate = templateTask.scheduledDaysFromNow 
            ? new Date(Date.now() + templateTask.scheduledDaysFromNow * 24 * 60 * 60 * 1000)
            : null;

          const task = await storage.createTask({
            title: templateTask.title,
            category: templateTask.category,
            priority: templateTask.priority,
            userId: userId,
            completed: false,
            timer: templateTask.timer || null,
            youtubeUrl: null,
            scheduledDate: scheduledDate,
            isRecurring: false,
            recurringFrequency: null,
            recurringInterval: null,
            parentTaskId: null,
            checklistItems: [],
            displayOrder: 0,
            completedAt: null,
            nextDueDate: null,
            endDate: null,
            daysOfWeek: null,
            dayOfMonth: null,
            monthOfYear: null,
            archived: false,
            archivedAt: null
          });
          createdTasks.push(task);
        }
      }

      // Increment usage count
      await storage.incrementTemplateUsage(templateId);
      
      const message = mode === "checklist" 
        ? `Created checklist task with ${template.tasks.length} items from template`
        : `Created ${createdTasks.length} tasks from template`;
        
      res.json({ createdTasks, message });
    } catch (error) {
      handleRouteError(error, req, res, "Use template");
    }
  });

  app.post('/api/templates/save', requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { name, description, category, taskIds } = req.body;
      
      if (!name || !taskIds || !Array.isArray(taskIds)) {
        return res.status(400).json({ message: "Name and task IDs are required" });
      }

      // Get selected tasks and convert to template format
      const selectedTasks = await storage.getTasksByIds(taskIds, userId);
      const templateTasks = selectedTasks.map(task => ({
        title: task.title,
        category: task.category,
        priority: task.priority as any,
        timer: task.timer,
        description: undefined
      }));

      const template = await storage.createTemplate({
        name,
        description: description || `Custom template with ${templateTasks.length} tasks`,
        category: category || 'Personal',
        tasks: templateTasks,
        isPublic: false,
        createdByUserId: userId,
        tags: []
      });

      res.json({ template, message: "Template saved successfully" });
    } catch (error) {
      handleRouteError(error, req, res, "Save template");
    }
  });

  // DELETE endpoint for quick template removal
  app.delete('/api/templates/:id', requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const templateId = parseInt(req.params.id);

      if (isNaN(templateId)) {
        return res.status(400).json({ message: 'Invalid template ID' });
      }

      // Only allow deletion of user-created templates
      const deleted = await storage.deleteUserTemplate(templateId, userId);
      
      if (!deleted) {
        return res.status(404).json({ message: 'Template not found or not authorized to delete' });
      }

      res.json({ success: true, message: 'Template deleted successfully' });
    } catch (error) {
      handleRouteError(error, req, res, "Delete template");
    }
  });

  // Print endpoint for generating professional reports
  app.post('/api/print', requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { request } = req.body;

      if (!request) {
        return res.status(400).json({ 
          success: false, 
          error: 'Print request is required' 
        });
      }

      // Import printingService
      const { printingService } = await import('./printingService');
      
      // Handle the print request using the printing service
      const printResult = await printingService.handlePrintRequest(request, userId);
      
      if (printResult.success) {
        res.json({
          success: true,
          title: printResult.title,
          content: printResult.content
        });
      } else {
        res.status(500).json({
          success: false,
          error: printResult.error || 'Failed to generate report'
        });
      }
    } catch (error) {
      console.error('Print endpoint error:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error while generating report'
      });
    }
  });

  // AIDOMO Conversation Management Routes
  
  // Get user's AIDOMO conversations
  app.get("/api/aidomo/conversations", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const conversations = await storage.getUserAidomoConversations(userId);
      
      logger.info("Retrieved user AIDOMO conversations", { userId, count: conversations.length });
      res.json(conversations);
    } catch (error) {
      logger.error("Error retrieving AIDOMO conversations", { error });
      res.status(500).json({ message: "Failed to retrieve conversations" });
    }
  });

  // Create new AIDOMO conversation
  app.post("/api/aidomo/conversations", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { title } = req.body;
      
      const sessionId = uuidv4();
      const conversationData = {
        userId,
        sessionId,
        title: title || "New Conversation",
        messages: [],
        totalMessages: 0,
        totalTokensUsed: 0,
        lastMessageAt: new Date(),
        isArchived: false,
      };
      
      const conversation = await storage.createAidomoConversation(conversationData);
      
      logger.info("Created new AIDOMO conversation", { sessionId, userId, title });
      res.json(conversation);
    } catch (error) {
      logger.error("Error creating AIDOMO conversation", { error });
      res.status(500).json({ message: "Failed to create conversation" });
    }
  });

  // Get specific AIDOMO conversation
  app.get("/api/aidomo/conversations/:sessionId", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { sessionId } = req.params;
      
      const conversation = await storage.getAidomoConversation(sessionId, userId);
      
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      
      res.json(conversation);
    } catch (error) {
      logger.error("Error retrieving AIDOMO conversation", { error });
      res.status(500).json({ message: "Failed to retrieve conversation" });
    }
  });

  // Add message to AIDOMO conversation
  app.post("/api/aidomo/conversations/:sessionId/messages", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { sessionId } = req.params;
      const { role, content, tokensUsed } = req.body;
      
      if (!role || !content) {
        return res.status(400).json({ message: "Role and content are required" });
      }
      
      // Verify conversation belongs to user
      const conversation = await storage.getAidomoConversation(sessionId, userId);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      
      const message = {
        role,
        content,
        timestamp: new Date().toISOString(),
        tokensUsed: tokensUsed || 0,
      };
      
      await storage.addMessageToConversation(sessionId, message);
      
      // If tokens were used, deduct from user's balance
      if (tokensUsed > 0) {
        await storage.deductTokens(userId, tokensUsed);
      }
      
      logger.info("Added message to AIDOMO conversation", { sessionId, role, tokensUsed });
      res.json({ success: true, message: "Message added to conversation" });
    } catch (error) {
      logger.error("Error adding message to conversation", { error });
      res.status(500).json({ message: "Failed to add message" });
    }
  });

  // Archive AIDOMO conversation
  app.put("/api/aidomo/conversations/:sessionId/archive", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { sessionId } = req.params;
      
      const success = await storage.archiveAidomoConversation(sessionId, userId);
      
      if (!success) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      
      logger.info("Archived AIDOMO conversation", { sessionId, userId });
      res.json({ success: true, message: "Conversation archived" });
    } catch (error) {
      logger.error("Error archiving conversation", { error });
      res.status(500).json({ message: "Failed to archive conversation" });
    }
  });

  // AIDOMO Token Management Routes
  
  // Get user's AIDOMO token status
  app.get("/api/aidomo/tokens", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const tokens = await storage.getUserAidomoTokens(userId);
      
      // Calculate available tokens
      const availableTokens = tokens.monthlyLimit + tokens.bonusTokens - tokens.currentUsage;
      
      const tokenStatus = {
        ...tokens,
        availableTokens,
        percentUsed: Math.round((tokens.currentUsage / (tokens.monthlyLimit + tokens.bonusTokens)) * 100),
      };
      
      logger.info("Retrieved user AIDOMO tokens", { userId, availableTokens });
      res.json(tokenStatus);
    } catch (error) {
      logger.error("Error retrieving AIDOMO tokens", { error });
      res.status(500).json({ message: "Failed to retrieve token status" });
    }
  });

  // Check if user has enough tokens for a request
  app.post("/api/aidomo/tokens/check", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { tokensNeeded } = req.body;
      
      if (!tokensNeeded || tokensNeeded <= 0) {
        return res.status(400).json({ message: "Valid tokensNeeded value is required" });
      }
      
      const hasEnoughTokens = await storage.checkTokenLimit(userId, tokensNeeded);
      const userTokens = await storage.getUserAidomoTokens(userId);
      const availableTokens = userTokens.monthlyLimit + userTokens.bonusTokens - userTokens.currentUsage;
      
      res.json({ 
        hasEnoughTokens,
        tokensNeeded,
        availableTokens,
        message: hasEnoughTokens ? "Sufficient tokens available" : "Insufficient tokens"
      });
    } catch (error) {
      logger.error("Error checking token limit", { error });
      res.status(500).json({ message: "Failed to check token limit" });
    }
  });

  // Add bonus tokens to user account (admin only)
  app.post("/api/aidomo/tokens/bonus", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { bonusTokens, targetUserId } = req.body;
      
      // Check if user is admin
      const user = await storage.getUserById(userId);
      if (!user || (user as any).role !== 'admin') {
        return res.status(403).json({ message: "Admin privileges required" });
      }
      
      if (!bonusTokens || bonusTokens <= 0) {
        return res.status(400).json({ message: "Valid bonusTokens value is required" });
      }
      
      const recipientUserId = targetUserId || userId;
      await storage.addBonusTokens(recipientUserId, bonusTokens);
      
      logger.info("Added bonus AIDOMO tokens", { recipientUserId, bonusTokens, adminUserId: userId });
      res.json({ success: true, message: `Added ${bonusTokens} bonus tokens` });
    } catch (error) {
      logger.error("Error adding bonus tokens", { error });
      res.status(500).json({ message: "Failed to add bonus tokens" });
    }
  });

  // Reset monthly tokens (admin only)
  app.post("/api/aidomo/tokens/reset", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { targetUserId } = req.body;
      
      // Check if user is admin
      const user = await storage.getUserById(userId);
      if (!user || (user as any).role !== 'admin') {
        return res.status(403).json({ message: "Admin privileges required" });
      }
      
      const recipientUserId = targetUserId || userId;
      await storage.resetMonthlyTokens(recipientUserId);
      
      logger.info("Reset monthly AIDOMO tokens", { recipientUserId, adminUserId: userId });
      res.json({ success: true, message: "Monthly tokens reset" });
    } catch (error) {
      logger.error("Error resetting monthly tokens", { error });
      res.status(500).json({ message: "Failed to reset monthly tokens" });
    }
  });

  // Calendar conflict resolution endpoints
  // Get all calendar events for a specific date
  app.get("/api/calendar/events", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { date } = req.query;
      
      if (!date) {
        return res.status(400).json({ message: "Date parameter is required" });
      }
      
      const events = await storage.getEventsByDate(userId, new Date(date as string));
      
      logger.info("Retrieved calendar events", { userId, date, count: events.length });
      res.json(events);
    } catch (error) {
      logger.error("Error getting calendar events", { error });
      res.status(500).json({ message: "Failed to get calendar events" });
    }
  });

  // Detect calendar conflicts for a specific date
  app.post("/api/calendar/conflicts/detect", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { date, eventId, time } = req.body;
      
      if (!date) {
        return res.status(400).json({ message: "Date is required" });
      }
      
      const conflicts = await storage.detectCalendarConflicts(
        userId, 
        new Date(date),
        eventId,
        time ? new Date(time) : undefined
      );
      
      logger.info("Detected calendar conflicts", { 
        userId, 
        date, 
        conflictCount: conflicts.conflicts.length 
      });
      
      res.json(conflicts);
    } catch (error) {
      logger.error("Error detecting calendar conflicts", { error });
      res.status(500).json({ message: "Failed to detect calendar conflicts" });
    }
  });

  // Suggest rescheduling options for conflicts
  app.post("/api/calendar/reschedule/suggest", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { date, target, constraints, preferences } = req.body;
      
      if (!date) {
        return res.status(400).json({ message: "Date is required" });
      }
      
      const proposals = await storage.suggestRescheduling(
        userId,
        new Date(date),
        { target, constraints, preferences }
      );
      
      logger.info("Generated rescheduling proposals", { 
        userId, 
        date, 
        proposalCount: proposals.length 
      });
      
      res.json({ proposals });
    } catch (error) {
      logger.error("Error suggesting rescheduling", { error });
      res.status(500).json({ message: "Failed to suggest rescheduling" });
    }
  });

  // Apply rescheduling changes
  app.post("/api/calendar/reschedule/apply", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { changes } = req.body;
      
      if (!changes || !Array.isArray(changes)) {
        return res.status(400).json({ message: "Changes array is required" });
      }
      
      // Validate changes format
      for (const change of changes) {
        if (!change.id || !change.scheduledDate) {
          return res.status(400).json({ message: "Each change must have id and scheduledDate" });
        }
      }
      
      // Convert dates
      const formattedChanges = changes.map(c => ({
        id: c.id,
        scheduledDate: new Date(c.scheduledDate),
        scheduledEnd: c.scheduledEnd ? new Date(c.scheduledEnd) : undefined
      }));
      
      const updatedTasks = await storage.applyRescheduling(userId, formattedChanges);
      
      logger.info("Applied rescheduling changes", { 
        userId, 
        changesCount: changes.length 
      });
      
      res.json({ updated: updatedTasks });
    } catch (error) {
      logger.error("Error applying rescheduling", { error });
      res.status(500).json({ message: "Failed to apply rescheduling" });
    }
  });

  // Update a single task's scheduling information
  app.patch("/api/tasks/:id/schedule", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const taskId = req.params.id;
      const { scheduledDate, scheduledEnd, durationMin, bufferBeforeMin, bufferAfterMin, isFixed } = req.body;
      
      const updates: any = {};
      if (scheduledDate !== undefined) updates.scheduledDate = new Date(scheduledDate);
      if (scheduledEnd !== undefined) updates.scheduledEnd = new Date(scheduledEnd);
      if (durationMin !== undefined) updates.durationMin = durationMin;
      if (bufferBeforeMin !== undefined) updates.bufferBeforeMin = bufferBeforeMin;
      if (bufferAfterMin !== undefined) updates.bufferAfterMin = bufferAfterMin;
      if (isFixed !== undefined) updates.isFixed = isFixed;
      
      const updatedTask = await storage.updateTask(taskId, updates);
      
      if (!updatedTask) {
        return res.status(404).json({ message: "Task not found" });
      }
      
      logger.info("Updated task schedule", { userId, taskId });
      res.json(updatedTask);
    } catch (error) {
      logger.error("Error updating task schedule", { error });
      res.status(500).json({ message: "Failed to update task schedule" });
    }
  });

  // Analytics API endpoints
  
  // Track page views and events
  app.post("/api/analytics/track", async (req: Request, res: Response) => {
    try {
      const { action, category, label, value, sessionId, visitorId, timestamp, url, userAgent } = req.body;
      const userId = (req as any).userId;
      const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
      
      // Track as an event
      await storage.trackEvent({
        userId,
        eventType: action,
        eventData: { category, label, value, url },
        sessionId,
        ipAddress: ip as string,
        userAgent,
        platform: 'web',
      });
      
      // Track page view if it's a page view event
      if (action === 'page_view' && url) {
        const path = new URL(url).pathname;
        await storage.trackPageView({
          sessionId,
          visitorId,
          userId,
          path,
          title: label,
          referrer: req.headers.referer,
        });
      }
      
      res.json({ success: true });
    } catch (error) {
      logger.error("Error tracking analytics", { error });
      res.status(500).json({ success: false });
    }
  });
  
  // Create visitor session
  app.post("/api/analytics/session", async (req: Request, res: Response) => {
    try {
      const { visitorId } = req.body;
      const userId = (req as any).userId;
      const userAgent = req.headers['user-agent'];
      const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
      
      // Parse user agent for device info
      const isMobile = /mobile/i.test(userAgent || '');
      const isTablet = /tablet/i.test(userAgent || '');
      const device = isTablet ? 'tablet' : isMobile ? 'mobile' : 'desktop';
      
      const sessionId = await storage.createVisitorSession({
        visitorId,
        userId,
        ipAddress: ip as string,
        userAgent,
        referrer: req.headers.referer,
        landingPage: req.headers.referer || '/',
        device,
      });
      
      res.json({ sessionId });
    } catch (error) {
      logger.error("Error creating session", { error });
      res.status(500).json({ error: "Failed to create session" });
    }
  });
  
  // Get analytics dashboard (admin only)
  app.get("/api/analytics/dashboard", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      
      // Check if user is admin
      const user = await storage.getUserById(userId);
      if (!user || (user as any).role !== 'admin') {
        return res.status(403).json({ message: "Admin privileges required" });
      }
      
      const dashboard = await storage.getAnalyticsDashboard();
      res.json(dashboard);
    } catch (error) {
      logger.error("Error getting analytics dashboard", { error });
      res.status(500).json({ message: "Failed to get analytics dashboard" });
    }
  });
  
  // Get site analytics for date range (admin only)
  app.get("/api/analytics/site", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      
      // Check if user is admin
      const user = await storage.getUserById(userId);
      if (!user || (user as any).role !== 'admin') {
        return res.status(403).json({ message: "Admin privileges required" });
      }
      
      const { startDate, endDate } = req.query;
      
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "Start date and end date are required" });
      }
      
      const analytics = await storage.getSiteAnalytics(
        new Date(startDate as string),
        new Date(endDate as string)
      );
      
      res.json(analytics);
    } catch (error) {
      logger.error("Error getting site analytics", { error });
      res.status(500).json({ message: "Failed to get site analytics" });
    }
  });
  
  // Get visitor sessions (admin only)
  app.get("/api/analytics/sessions", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      
      // Check if user is admin
      const user = await storage.getUserById(userId);
      if (!user || (user as any).role !== 'admin') {
        return res.status(403).json({ message: "Admin privileges required" });
      }
      
      const { startDate, endDate, isLoggedIn } = req.query;
      
      const filters: any = {};
      if (startDate) filters.startDate = new Date(startDate as string);
      if (endDate) filters.endDate = new Date(endDate as string);
      if (isLoggedIn !== undefined) filters.isLoggedIn = isLoggedIn === 'true';
      
      const sessions = await storage.getVisitorSessions(filters);
      res.json(sessions);
    } catch (error) {
      logger.error("Error getting visitor sessions", { error });
      res.status(500).json({ message: "Failed to get visitor sessions" });
    }
  });
  
  // Get page views (admin only)
  app.get("/api/analytics/pageviews", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      
      // Check if user is admin
      const user = await storage.getUserById(userId);
      if (!user || (user as any).role !== 'admin') {
        return res.status(403).json({ message: "Admin privileges required" });
      }
      
      const { sessionId } = req.query;
      const pageviews = await storage.getPageViews(sessionId as string);
      res.json(pageviews);
    } catch (error) {
      logger.error("Error getting page views", { error });
      res.status(500).json({ message: "Failed to get page views" });
    }
  });

  // Track user login for analytics
  app.post("/api/analytics/login", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { sessionId } = req.body;
      
      // Track login event
      await storage.trackEvent({
        userId,
        eventType: 'login',
        eventData: {},
        sessionId,
        platform: 'web',
      });
      
      // Update visitor session to mark as logged in
      if (sessionId) {
        await storage.updateVisitorSession(sessionId, {
          userId,
          isLoggedIn: true,
        });
      }
      
      res.json({ success: true });
    } catch (error) {
      logger.error("Error tracking login", { error });
      res.status(500).json({ success: false });
    }
  });

  // Register enhanced voice authentication routes
  registerEnhancedVoiceAuthRoutes(app);

  // ==================== SCHEDULING ROUTES ====================
  
  // Get user's scheduling settings (authenticated)
  app.get("/api/scheduling/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      let settings = await storage.getSchedulingSettings(userId);
      
      // If no settings exist, create default settings
      if (!settings) {
        const user = await storage.getUserById(userId);
        if (!user) {
          return res.status(404).json({ message: "User not found" });
        }
        
        // Generate a default slug from username
        const defaultSlug = user.username.toLowerCase().replace(/[^a-z0-9-]/g, '-');
        
        settings = await storage.createSchedulingSettings({
          userId,
          slug: defaultSlug,
          isEnabled: false,
          bookingWindowDays: 30,
          minNoticeMinutes: 60,
          slotDuration: 30,
          availability: {
            monday: { enabled: true, slots: [{ start: "09:00", end: "17:00" }] },
            tuesday: { enabled: true, slots: [{ start: "09:00", end: "17:00" }] },
            wednesday: { enabled: true, slots: [{ start: "09:00", end: "17:00" }] },
            thursday: { enabled: true, slots: [{ start: "09:00", end: "17:00" }] },
            friday: { enabled: true, slots: [{ start: "09:00", end: "17:00" }] },
            saturday: { enabled: false, slots: [] },
            sunday: { enabled: false, slots: [] },
          },
          meetingTitle: "Meeting",
          meetingDescription: "",
          timezone: user.timezone || "America/New_York",
        });
      }
      
      res.json(settings);
    } catch (error) {
      logger.error("Error getting scheduling settings", { error });
      res.status(500).json({ message: "Failed to get scheduling settings" });
    }
  });

  // Update user's scheduling settings (authenticated)
  app.put("/api/scheduling/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const updates = req.body;
      
      const settings = await storage.updateSchedulingSettings(userId, updates);
      
      if (!settings) {
        return res.status(404).json({ message: "Scheduling settings not found" });
      }
      
      res.json(settings);
    } catch (error) {
      logger.error("Error updating scheduling settings", { error });
      res.status(500).json({ message: "Failed to update scheduling settings" });
    }
  });

  // Get user's appointments (authenticated)
  app.get("/api/scheduling/appointments", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const appointments = await storage.getUserAppointments(userId);
      res.json(appointments);
    } catch (error) {
      logger.error("Error getting appointments", { error });
      res.status(500).json({ message: "Failed to get appointments" });
    }
  });

  // Update appointment status (authenticated)
  app.patch("/api/scheduling/appointments/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = (req as any).userId;
      const { id } = req.params;
      const { status } = req.body;
      
      // Verify appointment belongs to user
      const appointment = await storage.getAppointment(id);
      if (!appointment) {
        return res.status(404).json({ message: "Appointment not found" });
      }
      
      if (appointment.userId !== userId) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      const updated = await storage.updateAppointmentStatus(id, status);
      res.json(updated);
    } catch (error) {
      logger.error("Error updating appointment", { error });
      res.status(500).json({ message: "Failed to update appointment" });
    }
  });

  // PUBLIC: Get availability for booking (by slug)
  app.get("/public/schedule/:slug", async (req: Request, res: Response) => {
    try {
      const { slug } = req.params;
      const settings = await storage.getSchedulingSettingsBySlug(slug);
      
      if (!settings || !settings.isEnabled) {
        return res.status(404).json({ message: "Scheduling not available" });
      }
      
      // Get user info (limited data for public view)
      const user = await storage.getUserById(settings.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Return public-safe data
      res.json({
        slug: settings.slug,
        meetingTitle: settings.meetingTitle,
        meetingDescription: settings.meetingDescription,
        slotDuration: settings.slotDuration,
        availability: settings.availability,
        timezone: settings.timezone,
        bookingWindowDays: settings.bookingWindowDays,
        minNoticeMinutes: settings.minNoticeMinutes,
        hostName: user.fullName || user.username,
        hostProfilePicture: user.profilePictureUrl,
      });
    } catch (error) {
      logger.error("Error getting public schedule", { error });
      res.status(500).json({ message: "Failed to get schedule" });
    }
  });

  // PUBLIC: Book an appointment
  app.post("/public/schedule/:slug/book", async (req: Request, res: Response) => {
    try {
      const { slug } = req.params;
      const { attendeeName, attendeeEmail, attendeeNotes, startTime, endTime } = req.body;
      
      // Validate required fields
      if (!attendeeName || !attendeeEmail || !startTime || !endTime) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      
      // Get settings
      const settings = await storage.getSchedulingSettingsBySlug(slug);
      if (!settings || !settings.isEnabled) {
        return res.status(404).json({ message: "Scheduling not available" });
      }
      
      // TODO: Validate time slot is available (no conflicts with existing appointments)
      const startDate = new Date(startTime);
      const endDate = new Date(endTime);
      
      // Check for conflicts
      const existingAppointments = await storage.getAppointmentsByDateRange(
        settings.userId,
        startDate,
        endDate
      );
      
      const hasConflict = existingAppointments.some(appt => {
        const apptStart = new Date(appt.startTime);
        const apptEnd = new Date(appt.endTime);
        return (
          (startDate >= apptStart && startDate < apptEnd) ||
          (endDate > apptStart && endDate <= apptEnd) ||
          (startDate <= apptStart && endDate >= apptEnd)
        );
      });
      
      if (hasConflict) {
        return res.status(409).json({ message: "Time slot is not available" });
      }
      
      // Generate cancellation token
      const cancellationToken = crypto.randomBytes(32).toString('hex');
      
      // Create appointment
      const appointment = await storage.createAppointment({
        userId: settings.userId,
        attendeeName,
        attendeeEmail,
        attendeeNotes: attendeeNotes || null,
        startTime: startDate,
        endTime: endDate,
        status: "scheduled",
        cancellationToken,
        metadata: {},
        taskId: null,
      });
      
      // Create a task for the appointment on the user's calendar
      const task = await storage.createTask({
        title: `Meeting: ${attendeeName}`,
        category: "Business",
        priority: "High",
        completed: false,
        scheduledDate: startDate,
        scheduledEnd: endDate,
        userId: settings.userId,
        displayOrder: 0,
        isFixed: false,
        isRecurring: false,
        archived: false,
        checklistItems: [],
        timer: null,
        youtubeUrl: null,
        durationMin: Math.round((endDate.getTime() - startDate.getTime()) / 60000),
        bufferBeforeMin: 5,
        bufferAfterMin: 5,
        flexibility: null,
        dependencyIds: null,
        completedAt: null,
        recurringFrequency: null,
        recurringInterval: null,
        nextDueDate: null,
        endDate: null,
        daysOfWeek: null,
        dayOfMonth: null,
        monthOfYear: null,
        parentTaskId: null,
        archivedAt: null,
      });
      
      // Update appointment with task ID to link them
      await db.update(appointments).set({ taskId: task.id }).where(eq(appointments.id, appointment.id));
      
      res.json({
        success: true,
        appointmentId: appointment.id,
        cancellationToken: appointment.cancellationToken,
      });
    } catch (error) {
      logger.error("Error booking appointment", { error });
      res.status(500).json({ message: "Failed to book appointment" });
    }
  });

  // PUBLIC: Cancel an appointment
  app.post("/public/schedule/:slug/cancel", async (req: Request, res: Response) => {
    try {
      const { cancellationToken } = req.body;
      
      if (!cancellationToken) {
        return res.status(400).json({ message: "Cancellation token required" });
      }
      
      const appointment = await storage.getAppointmentByCancellationToken(cancellationToken);
      if (!appointment) {
        return res.status(404).json({ message: "Appointment not found" });
      }
      
      await storage.updateAppointmentStatus(appointment.id, "cancelled");
      
      res.json({ success: true, message: "Appointment cancelled" });
    } catch (error) {
      logger.error("Error cancelling appointment", { error });
      res.status(500).json({ message: "Failed to cancel appointment" });
    }
  });

  const httpServer = createServer(app);
  
  // Start scheduled jobs
  taskScheduler.startAllJobs();
  
  // Setup SEO routes (sitemap, robots.txt, etc.)
  setupSEORoutes(app);
  
  // Set up WebSocket server for real-time updates
  const wss = new WebSocketServer({ server: httpServer, path: '/ws' });
  
  wss.on('connection', (ws) => {
    logger.info('WebSocket client connected');
    
    ws.on('message', (message) => {
      try {
        const data = JSON.parse(message.toString());
        logger.debug('WebSocket message received', { type: data.type });
        
        // Handle different message types
        if (data.type === 'subscribe') {
          ws.send(JSON.stringify({ type: 'subscribed', channel: data.channel }));
        }
      } catch (error) {
        logger.error('Error processing WebSocket message', { error });
      }
    });
    
    ws.on('close', () => {
      logger.info('WebSocket client disconnected');
    });
  });
  
  return httpServer;
}
