import OpenAI from "openai";
import { storage } from "./storage";
import { Task, InsertTask } from "@shared/schema";
import { templateManager } from "./templateManager";
import { printingService } from "./printingService";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
const MODEL = "gpt-4o";

interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

interface TaskCreationRequest {
  title: string;
  category?: string;
  priority?: 'Low' | 'Medium' | 'High';
  timer?: number;
  youtubeUrl?: string;
  scheduledDate?: string;
  needsCalendar?: boolean;
}

interface RollingTasksRequest {
  tasks: TaskCreationRequest[];
}

interface ChecklistCreationRequest {
  title: string;
  category?: string;
  priority?: 'Low' | 'Medium' | 'High';
  checklistItems: Array<{
    text: string;
    completed: boolean;
  }>;
}

interface TemplateRecommendation {
  templates: Array<{
    name: string;
    description: string;
    category: string;
    reason: string;
  }>;
}

export class DomoAI {
  private templates: any[] = [];

  constructor() {
    this.loadTemplates();
  }

  private async loadTemplates() {
    try {
      this.templates = await storage.getTemplates();
    } catch (error) {
      console.error("Error loading templates:", error);
      this.templates = [];
    }
  }
  // Secure method to get high priority tasks - only accessible by authenticated user request
  async getHighPriorityTasks(userId: number): Promise<Task[]> {
    try {
      if (!userId) {
        throw new Error("User authentication required for high priority task access");
      }
      
      const highPriorityTasks = await storage.getHighPriorityTasks(userId);
      return highPriorityTasks;
    } catch (error) {
      console.error("Error accessing high priority tasks:", error);
      throw error;
    }
  }

  private getTemplateList(): string {
    const templatesByCategory = this.templates.reduce((acc, template) => {
      if (!acc[template.category]) {
        acc[template.category] = [];
      }
      acc[template.category].push(`${template.name}: ${template.description}`);
      return acc;
    }, {} as Record<string, string[]>);

    let templateList = "Available templates by category:\n";
    for (const [category, templates] of Object.entries(templatesByCategory)) {
      templateList += `\n${category}:\n`;
      (templates as string[]).forEach(t => {
        templateList += `- ${t}\n`;
      });
    }
    return templateList;
  }

  async getTemplateRecommendations(userContext: string): Promise<TemplateRecommendation> {
    try {
      const neurodiverseTemplates = this.templates.filter(t => t.category === 'Neurodiverse-Friendly');
      const allTemplates = this.templates;

      const response = await openai.chat.completions.create({
        model: MODEL,
        messages: [
          {
            role: "system",
            content: `You are an expert at matching users with the perfect productivity templates. Analyze the user's needs and recommend 2-3 most relevant templates.

PRIORITIZE ADHD/NEURODIVERSE TEMPLATES when user mentions:
- ADHD, ADD, or neurodiversity
- Difficulty focusing, getting started, or overwhelm
- Need for structure, micro-steps, or time-boxing
- Executive function challenges
- Hyperfocus issues

Available Neurodiverse-Friendly Templates:
${neurodiverseTemplates.map(t => `- ${t.name}: ${t.description}`).join('\n')}

${this.getTemplateList()}

Respond in JSON format with template recommendations and reasons why each is perfect for them.`
          },
          {
            role: "user",
            content: userContext
          }
        ],
        response_format: { type: "json_object" },
        temperature: 0.7,
      });

      const result = JSON.parse(response.choices[0].message.content || '{}');
      return result;
    } catch (error) {
      console.error("Error getting template recommendations:", error);
      return { templates: [] };
    }
  }

  async applyADHDTemplate(templateName: string, userId: number): Promise<any> {
    try {
      // Reload templates to ensure we have the latest
      await this.loadTemplates();
      
      // Handle applying ALL ADHD templates
      if (templateName === 'ALL_ADHD') {
        const adhdTemplates = this.templates.filter(t => t.category === 'Neurodiverse-Friendly');
        let allCreatedTasks = [];
        let appliedTemplates = [];
        
        for (const template of adhdTemplates) {
          // Create tasks from each template
          for (const templateTask of template.tasks) {
            const scheduledDate = templateTask.scheduledDaysFromNow 
              ? new Date(Date.now() + templateTask.scheduledDaysFromNow * 24 * 60 * 60 * 1000)
              : undefined;

            const task = await storage.createTask({
              title: `[${template.name}] ${templateTask.title}`,
              category: templateTask.category,
              priority: templateTask.priority,
              userId: userId,
              completed: false,
              completedAt: null,
              timer: templateTask.timer || null,
              youtubeUrl: null,
              displayOrder: 0,
              scheduledDate: scheduledDate || null,
              isRecurring: false,
              recurringFrequency: null,
              recurringInterval: null,
              parentTaskId: null,
              nextDueDate: null,
              endDate: null,
              daysOfWeek: null,
              dayOfMonth: null,
              monthOfYear: null,
              archived: false,
              archivedAt: null,
              checklistItems: []
            });
            allCreatedTasks.push(task);
          }
          
          // Increment template usage
          await storage.incrementTemplateUsage(template.id);
          appliedTemplates.push(template.name);
        }
        
        return {
          templateName: 'All ADHD Super Hero Templates',
          tasksCreated: allCreatedTasks.length,
          tasks: allCreatedTasks,
          appliedTemplates: appliedTemplates
        };
      }
      
      // Handle single template application
      const template = this.templates.find(t => 
        t.name.toLowerCase().includes(templateName.toLowerCase()) ||
        templateName.toLowerCase().includes(t.name.toLowerCase())
      );
      
      if (!template) {
        console.error(`Template not found: ${templateName}`);
        return null;
      }

      // Create tasks from the template
      const createdTasks = [];
      for (const templateTask of template.tasks) {
        const scheduledDate = templateTask.scheduledDaysFromNow 
          ? new Date(Date.now() + templateTask.scheduledDaysFromNow * 24 * 60 * 60 * 1000)
          : undefined;

        const task = await storage.createTask({
          title: templateTask.title,
          category: templateTask.category,
          priority: templateTask.priority,
          userId: userId,
          completed: false,
          completedAt: null,
          timer: templateTask.timer || null,
          youtubeUrl: null,
          displayOrder: 0,
          scheduledDate: scheduledDate || null,
          isRecurring: false,
          recurringFrequency: null,
          recurringInterval: null,
          parentTaskId: null,
          nextDueDate: null,
          endDate: null,
          daysOfWeek: null,
          dayOfMonth: null,
          monthOfYear: null,
          archived: false,
          archivedAt: null,
          checklistItems: []
        });
        createdTasks.push(task);
      }

      // Increment template usage
      await storage.incrementTemplateUsage(template.id);
      
      return {
        templateName: template.name,
        tasksCreated: createdTasks.length,
        tasks: createdTasks
      };
    } catch (error) {
      console.error("Error applying ADHD template:", error);
      return null;
    }
  }

  private getSystemPrompt(): string {
    const currentDate = new Date();
    const today = currentDate.toISOString().split('T')[0]; // YYYY-MM-DD format
    const tomorrow = new Date(currentDate.getTime() + 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    return `You are DomoAI, a highly professional executive assistant for AICHECKLIST, serving business professionals and entrepreneurs. You embody corporate excellence with a refined, sophisticated personality - think of yourself as a blend between a Fortune 500 executive assistant and a strategic business advisor. You are also a diplomatic assistant with a full range of negotiation skills to promote successful transitions for multifaceted power structures. You maintain impeccable professionalism while incorporating subtle, appropriate business humor when fitting.

ADHD & TEMPLATE REQUESTS - CRITICAL:
When a user mentions any of these keywords:
- "ADHD", "ADD", "adhd todo list", "adhd template", "neurodiverse", "neurodivergent"
- "I need help focusing", "I'm overwhelmed", "can't get started", "executive function"
- "micro-steps", "time-boxing", "break things down", "smaller tasks"
- "templates", "template list", "show templates", "what templates"
- "show me adhd", "give me adhd", "add adhd template", "use adhd template"

Your response MUST START with this exact format:
TEMPLATE_REQUEST: [template_name]

Where [template_name] is ONE of these options based on what the user needs:
- "ADHD Daily Flow" - for general daily structure and focus
- "Executive Function Rescue" - when they're stuck or overwhelmed
- "ADHD Morning Momentum" - for starting the day right
- "ADHD End-of-Day Reset" - for ending the day organized
- "Hyperfocus Exit Strategy" - for transitioning out of hyperfocus
- "Essay/Report Scaffold" - for writing tasks
- "Interview/Presentation Prep" - for preparation tasks
- "ALL_ADHD" - if they ask for "all ADHD templates" or "all templates"

Then continue with your response explaining the Super Hero List and what template you're applying.

Examples:
- If user says "I can't get started": TEMPLATE_REQUEST: Executive Function Rescue
- If user says "I need morning help": TEMPLATE_REQUEST: ADHD Morning Momentum  
- If user says "apply all ADHD templates": TEMPLATE_REQUEST: ALL_ADHD
- If general ADHD request: TEMPLATE_REQUEST: ADHD Daily Flow

HIGH PRIORITY TASK REQUESTS:
When a user asks about high priority tasks (phrases like "high priority", "urgent tasks", "what's important", "priority tasks"), respond with:
HIGH_PRIORITY_REQUEST: true

This triggers secure access to their high priority tasks that only they can authorize.

PRINT REQUESTS - CRITICAL:
When a user asks to print anything (phrases like "print", "print my", "can you print", "print this", "print that") OR uses the SHORT COMMANDS "p checklist", "p todo", "p":

AIDOMO CONVERSATION PRINTING (DEFAULT):
For general print requests in the AIDOMO chat interface, prioritize printing the conversation:
PRINT_REQUEST: conversation

SPECIAL SHORT COMMANDS (DEFAULT TO CONVERSATION):
- "p" (alone) ‚Üí PRINT_REQUEST: conversation
- "print" ‚Üí PRINT_REQUEST: conversation  
- "print this" ‚Üí PRINT_REQUEST: conversation
- "print chat" ‚Üí PRINT_REQUEST: conversation

SPECIFIC TASK PRINTING (ONLY WHEN EXPLICITLY REQUESTED):
Only use task printing when the user specifically mentions tasks or lists:
- "print my todo list" ‚Üí PRINT_REQUEST: todo_list
- "print my checklist" ‚Üí PRINT_REQUEST: checklist  
- "print my work tasks" ‚Üí PRINT_REQUEST: work_tasks
- "print my personal tasks" ‚Üí PRINT_REQUEST: personal_tasks
- "print template list" ‚Üí PRINT_REQUEST: template_list
- "print high priority tasks" ‚Üí PRINT_REQUEST: high_priority_tasks
- "print my shopping list" ‚Üí PRINT_REQUEST: shopping_tasks
- "print my health tasks" ‚Üí PRINT_REQUEST: health_tasks
- "p checklist" ‚Üí PRINT_REQUEST: checklist
- "p todo" ‚Üí PRINT_REQUEST: todo_list

For conversation printing, explain that you're preparing a professional print-ready document of your conversation for immediate printing.

CURRENT DATE: ${today} (Today is ${currentDate.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })})
TOMORROW: ${tomorrow}

IMPORTANT: When users say "today", use ${today}. When they say "tomorrow", use ${tomorrow}. Calculate other dates relative to ${today}.

STRICT DATA PRIVACY & SECURITY:
- NEVER share personal user information, task details, or account data
- NEVER reveal information about other users or their tasks
- If asked about user data you don't have direct access to, say "I can only help with what you share with me directly"
- Protect all customer information as strictly confidential
- Only discuss tasks and information that the current user has explicitly shared in this conversation
- HIGH PRIORITY TASK ACCESS: Only show high priority tasks when the user specifically asks for them (e.g., "what are my high priority tasks?", "show me urgent tasks"). Never access task data automatically or for external sources.

FOCUS TIMER INTEGRATION - CRITICAL:
When discussing ANY productivity methods, time management, work sessions, breaks, or the Pomodoro Technique, you MUST ALWAYS reference the FOCUS Timer AND provide location instructions:
- "I recommend utilizing our FOCUS Timer - on the right side of your screen, look for the tab and set your timer for optimal work sessions"
- "The FOCUS Timer provides perfect 25-minute productivity intervals with built-in breaks. You'll find it on the right side of your screen - look for the tab and set your timer"
- "Leverage the FOCUS Timer to implement structured time-blocking methodology. Simply look on the right side of your screen for the tab and set your timer"
- "Our FOCUS Timer is specifically designed for professional productivity enhancement. On the right side of your screen, look for the tab and set your timer"
- ALWAYS include the instruction: "on the right side of your screen, look for the tab and set your timer"
- NEVER mention generic "Pomodoro timers," "external apps," or "other timer tools" - ONLY promote the built-in FOCUS Timer feature

CORE PERSONALITY & PROFESSIONAL STANDARDS:
- Maintain EXCEPTIONAL professionalism at ALL times - you represent executive-level service
- Use sophisticated business vocabulary and polished communication
- Address users with respect (e.g., "Certainly," "I'd be delighted to assist," "Excellent choice")
- Incorporate strategic business insights when discussing productivity and task management
- Use subtle, tasteful business humor sparingly (think Wall Street Journal, not water cooler)
- Demonstrate executive-level thinking: efficiency, ROI, strategic prioritization
- Always position yourself as their trusted business advisor, not just a task manager
- Language should reflect Harvard Business Review, not casual chat
- Example phrases: "Let me optimize your workflow," "I'll ensure maximum productivity," "Strategic task prioritization"

SAFETY GUIDELINES:
- Never provide inappropriate, harmful, or offensive content
- Avoid discussing politics, controversial topics, or anything that could be considered taboo
- If asked about sensitive topics, politely redirect to how you can help with their tasks or productivity
- Focus on being supportive and helpful rather than controversial

TASK CREATION INSTRUCTIONS:
When a user mentions creating a task, setting an alarm, or says something like "create task: [something]", "add task [something]", "set alarm for [something]", "remind me to [something]", "schedule [something]":

1. REMEMBER THE EXACT TASK: Store exactly what they want to do (e.g., "go faster", "buy groceries", "finish report")
2. IDENTIFY IF THEY WANT AN ALARM/TIMER: If they mention "alarm", "timer", "remind me in X minutes", or specific time duration
3. IDENTIFY IF THEY WANT CALENDAR SCHEDULING: If they mention dates like "tomorrow", "next week", "Monday", "December 5th", specific dates
4. Ask: "What category? Work, Personal, Shopping, Health, or Other?"
5. When they reply, create the task IMMEDIATELY with timer and/or scheduled date if mentioned

CHECKLIST CREATION INSTRUCTIONS:
When a user specifically asks for a checklist, like "create a checklist", "make an aichecklist", "checklist for [something]", "create checklist items":

1. DETECT CHECKLIST REQUEST: Look for words like "checklist", "check list", "aichecklist", "list with checkboxes"
2. EXTRACT CHECKLIST ITEMS: If they provide specific items, use those. If not, ask what items they want
3. Ask: "What category? Work, Personal, Shopping, Health, or Other?"
4. When they reply, create ONE TASK with multiple checklist items using CREATE_CHECKLIST format

CREATE_CHECKLIST format:
CREATE_CHECKLIST: {"title": "[checklist name]", "category": "[their category choice]", "priority": "Medium", "checklistItems": [{"text": "[item 1]", "completed": false}, {"text": "[item 2]", "completed": false}]}

CHECKLIST EXAMPLES:
1. User: "create an aichecklist"
   You: "I'll create a checklist for you! What items should be included? Please list them."
   User: "item 1, item 2, item 3"
   You: "Perfect! What category? Work, Personal, Shopping, Health, or Other?"
   User: "work"
   You generate: CREATE_CHECKLIST: {"title": "AIChecklist", "category": "Work", "priority": "Medium", "checklistItems": [{"text": "item 1", "completed": false}, {"text": "item 2", "completed": false}, {"text": "item 3", "completed": false}]}

2. User: "make a shopping checklist with milk, bread, eggs"
   You: "Creating a shopping checklist! What category? Work, Personal, Shopping, Health, or Other?"
   User: "shopping"
   You generate: CREATE_CHECKLIST: {"title": "Shopping Checklist", "category": "Shopping", "priority": "Medium", "checklistItems": [{"text": "milk", "completed": false}, {"text": "bread", "completed": false}, {"text": "eggs", "completed": false}]}

ROLLING TASK CREATION (NEW FEATURE):
When a user says multiple tasks in sequence like "task 1 task 2 task 3 task 4" or "create task one create task two create task three", this is a "rolling task" request:

1. DETECT ROLLING PATTERNS: Look for numbered sequences, multiple "task" mentions, or phrases like:
   - "task 1 task 2 task 3"
   - "task one task two task three"
   - "create task A create task B create task C"
   - "add meeting add research add presentation"
   - "first do X then do Y then do Z"

2. EXTRACT ALL TASKS: Parse each individual task from the sequence
3. Ask: "I see you want to create [NUMBER] tasks! What category should I use for all of them? Work, Personal, Shopping, Health, or Other?"
4. When they reply, create ALL tasks at once using ROLLING_TASKS format

Rolling task creation format:
ROLLING_TASKS: [
  {"title": "[first task]", "category": "[their category choice]", "priority": "Medium"},
  {"title": "[second task]", "category": "[their category choice]", "priority": "Medium"},
  {"title": "[third task]", "category": "[their category choice]", "priority": "Medium"}
]

ROLLING TASK EXAMPLES:
1. User: "task 1 task 2 task 3 task 4"
   You: "Perfect! I see you want to create 4 tasks. What category should I use for all of them? Work, Personal, Shopping, Health, or Other?"
   User: "work"
   You generate: ROLLING_TASKS: [{"title": "task 1", "category": "Work", "priority": "Medium"}, {"title": "task 2", "category": "Work", "priority": "Medium"}, {"title": "task 3", "category": "Work", "priority": "Medium"}, {"title": "task 4", "category": "Work", "priority": "Medium"}]

2. User: "add meeting add research add presentation"
   You: "Great! I'll create 3 tasks for you. What category? Work, Personal, Shopping, Health, or Other?"
   User: "work"
   You generate: ROLLING_TASKS: [{"title": "meeting", "category": "Work", "priority": "Medium"}, {"title": "research", "category": "Work", "priority": "Medium"}, {"title": "presentation", "category": "Work", "priority": "Medium"}]

ALARM/TIMER HANDLING:
- If user says "set alarm" or "set timer", extract the time in minutes
- Common patterns: "5 minute alarm", "alarm for 10 minutes", "remind me in 30 minutes"
- Include the timer in the task creation

Task creation format WITHOUT timer or date:
CREATE_TASK: {"title": "[exact user task here]", "category": "[their category choice]", "priority": "Medium"}

Task creation format WITH timer/alarm:
CREATE_TASK: {"title": "[exact user task here]", "category": "[their category choice]", "priority": "Medium", "timer": [minutes]}

Task creation format WITH calendar date:
CREATE_TASK: {"title": "[exact user task here]", "category": "[their category choice]", "priority": "Medium", "scheduledDate": "YYYY-MM-DD"}

Task creation format WITH BOTH timer and date:
CREATE_TASK: {"title": "[exact user task here]", "category": "[their category choice]", "priority": "Medium", "timer": [minutes], "scheduledDate": "YYYY-MM-DD"}

CALENDAR SCHEDULING EXAMPLES:
1. User: "Schedule a meeting tomorrow"
   You: "I'll schedule that meeting for tomorrow! What category? Work, Personal, Shopping, Health, or Other?"
   User: "work"
   You generate: CREATE_TASK: {"title": "meeting", "category": "Work", "priority": "Medium", "scheduledDate": "${tomorrow}"}

2. User: "Remind me to call mom on Friday"
   You: "I'll add that to your calendar for Friday! What category?"
   User: "personal"
   You generate: CREATE_TASK: {"title": "call mom", "category": "Personal", "priority": "Medium", "scheduledDate": "[calculate Friday's date from ${today}]"}

3. User: "Set a 10 minute timer for break tomorrow"
   You: "Perfect! A 10-minute break timer for tomorrow. What category?"
   User: "personal"
   You generate: CREATE_TASK: {"title": "break", "category": "Personal", "priority": "Medium", "timer": 10, "scheduledDate": "${tomorrow}"}

TIMER EXAMPLES:
1. User: "Set a 5 minute alarm"
   You: "Setting a 5-minute alarm! What category? Work, Personal, Shopping, Health, or Other?"
   User: "work"
   You generate: CREATE_TASK: {"title": "5 minute alarm", "category": "Work", "priority": "Medium", "timer": 5}

2. User: "Remind me to take a break in 15 minutes"
   You: "I'll remind you to take a break in 15 minutes! What category?"
   User: "personal"
   You generate: CREATE_TASK: {"title": "take a break", "category": "Personal", "priority": "Medium", "timer": 15}

After creating a single task say: "Excellent. Task successfully integrated into your workflow. What's your next strategic priority?"
After creating rolling tasks say: "Outstanding. All [NUMBER] deliverables have been strategically allocated to your portfolio. How may I further optimize your productivity?"

FOCUS TIMER INTEGRATION:
When discussing productivity methods, time management, work sessions, or the Pomodoro Technique, ALWAYS reference the FOCUS Timer:
- "I recommend utilizing our FOCUS Timer for optimal work sessions"
- "The FOCUS Timer provides perfect 25-minute productivity intervals"
- "Leverage the FOCUS Timer to implement structured time-blocking methodology"
- Never mention generic "Pomodoro timers" or "external apps" - always promote the built-in FOCUS Timer feature

PROFESSIONAL COMMUNICATION STANDARDS:
- Begin responses with executive-level acknowledgment (e.g., "Excellent.", "Certainly.", "I'll handle that immediately.")
- Use business terminology: "optimize", "leverage", "strategic", "deliverables", "actionable", "ROI", "bandwidth"
- Frame everything in terms of productivity, efficiency, and business value
- End with professional offers of continued service (e.g., "How else may I enhance your productivity today?")
- NEVER use emojis, casual slang, or overly familiar language
- Speak like a Harvard MBA serving a Fortune 500 executive

RESPONSE EXAMPLES:
Instead of: "Great! I'll help you with that!"
Say: "Excellent. I'll optimize that workflow for maximum efficiency."

Instead of: "No problem! What else do you need?"
Say: "Consider it handled. What's your next strategic priority?"

Always maintain this level of professionalism in EVERY response.`;
  }

  async chat(messages: ChatMessage[], userId: number, userMemory?: any): Promise<{ response: string; calendarConflicts?: any }> {
    try {
      // Get user's current tasks for context
      const userTasks = await storage.getAllTasks(userId);
      const taskContext = userTasks.length > 0 
        ? `\n\nCURRENT USER TASKS:\n${userTasks.map((task: Task) => 
            `- ${task.title} (${task.category}, ${task.priority}${task.completed ? ' - COMPLETED' : ''})`
          ).join('\n')}`
        : '\n\nUser has no current tasks.';

      // Add user memory context for personalized responses
      let memoryContext = '';
      if (userMemory) {
        memoryContext = '\n\nUSER MEMORY & CONTEXT:';
        
        if (userMemory.preferredName) {
          memoryContext += `\n- User prefers to be called: ${userMemory.preferredName}`;
        }
        
        if (userMemory.personalDetails && Object.keys(userMemory.personalDetails).length > 0) {
          const details = userMemory.personalDetails;
          if (details.occupation) memoryContext += `\n- Occupation: ${details.occupation}`;
          if (details.interests && details.interests.length > 0) memoryContext += `\n- Interests: ${details.interests.join(', ')}`;
          if (details.goals && details.goals.length > 0) memoryContext += `\n- Goals: ${details.goals.join(', ')}`;
          if (details.challenges && details.challenges.length > 0) memoryContext += `\n- Challenges: ${details.challenges.join(', ')}`;
          if (details.workStyle) memoryContext += `\n- Work Style: ${details.workStyle}`;
        }
        
        if (userMemory.userPreferences && Object.keys(userMemory.userPreferences).length > 0) {
          const prefs = userMemory.userPreferences;
          if (prefs.communicationStyle) memoryContext += `\n- Communication Preference: ${prefs.communicationStyle}`;
          if (prefs.responseLength) memoryContext += `\n- Response Length Preference: ${prefs.responseLength}`;
          if (prefs.motivationStyle) memoryContext += `\n- Motivation Style: ${prefs.motivationStyle}`;
        }
        
        if (userMemory.recentConversations && userMemory.recentConversations.length > 0) {
          memoryContext += '\n- Recent Topics: ' + userMemory.recentConversations
            .slice(-3) // Last 3 conversations
            .map(conv => conv.topic)
            .join(', ');
        }
        
        memoryContext += '\n\nUSE THIS CONTEXT to provide personalized, relevant responses that build on our relationship and past conversations.';
      }

      const systemPrompt = this.getSystemPrompt() + taskContext + memoryContext;

      const response = await openai.chat.completions.create({
        model: MODEL,
        messages: [
          { role: 'system', content: systemPrompt },
          ...messages
        ],
        max_tokens: 500,
        temperature: 0.7,
        presence_penalty: 0.2,
        frequency_penalty: 0.1,
      });

      const aiResponse = response.choices[0].message.content || "I apologize for the inconvenience. The system requires a moment to process. How may I assist with your strategic priorities?";
      
      // Check if the user is asking about calendar conflicts
      const lastMessage = messages[messages.length - 1]?.content || '';
      const conflictResolution = await this.detectAndResolveCalendarConflicts(lastMessage, userId);
      
      if (conflictResolution && conflictResolution.hasConflicts) {
        // Generate a response about the conflicts and proposals
        const conflictResponse = `I've detected ${conflictResolution.conflicts.length} scheduling conflict(s) in your calendar.

${conflictResolution.conflicts.map((c: any, i: number) => 
          `Conflict ${i+1}: ${c.task1.title} overlaps with ${c.task2.title} (${c.type})`
        ).join('\n')}

I've generated ${conflictResolution.proposals.length} rescheduling option(s) to resolve these conflicts. Would you like me to apply the optimal solution that minimizes disruption to your schedule?`;
        
        return {
          response: conflictResponse,
          calendarConflicts: conflictResolution
        };
      }
      
      return { response: aiResponse };
    } catch (error) {
      console.error('DomoAI chat error:', error);
      return { response: "I'm experiencing a temporary system optimization. Please allow me another moment to process your request for maximum efficiency." };
    }
  }

  async detectAndResolveCalendarConflicts(message: string, userId: number): Promise<any> {
    try {
      // Check if message mentions scheduling conflicts
      const conflictKeywords = [
        'conflict', 'overlap', 'clash', 'reschedule', 'move meeting', 
        'change time', 'busy at', 'can\'t make', 'double booked',
        'schedule issue', 'time collision'
      ];
      
      const mentionsConflict = conflictKeywords.some(keyword => 
        message.toLowerCase().includes(keyword)
      );
      
      if (!mentionsConflict) {
        return null;
      }
      
      // Enhanced date/time extraction with better parsing
      const today = new Date();
      let targetDate = new Date(today);
      targetDate.setHours(0, 0, 0, 0);
      
      // Extract date from message
      const datePatterns = [
        { pattern: /today/i, days: 0 },
        { pattern: /tomorrow/i, days: 1 },
        { pattern: /monday/i, dayOfWeek: 1 },
        { pattern: /tuesday/i, dayOfWeek: 2 },
        { pattern: /wednesday/i, dayOfWeek: 3 },
        { pattern: /thursday/i, dayOfWeek: 4 },
        { pattern: /friday/i, dayOfWeek: 5 },
        { pattern: /saturday/i, dayOfWeek: 6 },
        { pattern: /sunday/i, dayOfWeek: 0 },
      ];
      
      for (const dp of datePatterns) {
        if (dp.pattern.test(message)) {
          if (dp.days !== undefined) {
            targetDate.setDate(targetDate.getDate() + dp.days);
          } else if (dp.dayOfWeek !== undefined) {
            const currentDay = targetDate.getDay();
            const daysToAdd = (dp.dayOfWeek - currentDay + 7) % 7 || 7;
            targetDate.setDate(targetDate.getDate() + daysToAdd);
          }
          break;
        }
      }
      
      // Extract specific time if mentioned
      const timeMatch = message.match(/(\d{1,2})(:\d{2})?\s*(am|pm|a\.m\.|p\.m\.)?/i);
      if (timeMatch) {
        let hour = parseInt(timeMatch[1]);
        const minutes = timeMatch[2] ? parseInt(timeMatch[2].substring(1)) : 0;
        const meridian = timeMatch[3]?.toLowerCase();
        
        if (meridian && (meridian.includes('p') || meridian.includes('pm'))) {
          if (hour < 12) hour += 12;
        } else if (meridian && (meridian.includes('a') || meridian.includes('am'))) {
          if (hour === 12) hour = 0;
        }
        
        targetDate.setHours(hour, minutes, 0, 0);
      }
      
      // Detect conflicts for the target date
      const conflicts = await storage.detectCalendarConflicts(userId, targetDate);
      
      if (conflicts.conflicts.length === 0) {
        return {
          hasConflicts: false,
          message: "I've analyzed your calendar and found no scheduling conflicts for that time. Your schedule looks clear!"
        };
      }
      
      // Generate rescheduling suggestions
      const proposals = await storage.suggestRescheduling(
        userId, 
        targetDate,
        { conflicts: conflicts.conflicts }
      );
      
      return {
        hasConflicts: true,
        conflicts: conflicts.conflicts,
        proposals: proposals,
        targetDate: targetDate
      };
    } catch (error) {
      console.error('Error detecting calendar conflicts:', error);
      return null;
    }
  }

  async applyCalendarRescheduling(changes: any[], userId: number): Promise<any> {
    try {
      const updatedTasks = await storage.applyRescheduling(userId, changes);
      return {
        success: true,
        updatedTasks,
        message: `Successfully rescheduled ${updatedTasks.length} event(s) to resolve the conflicts.`
      };
    } catch (error) {
      console.error('Error applying rescheduling:', error);
      return {
        success: false,
        message: "I encountered an issue while rescheduling. Please try again."
      };
    }
  }

  async createTaskFromChat(taskData: TaskCreationRequest, userId: number): Promise<Task> {
    try {
      const taskInsert: Omit<Task, "id" | "createdAt"> = {
        title: taskData.title,
        category: taskData.category || 'Personal',
        priority: taskData.priority || 'Medium',
        completed: false,
        completedAt: null,
        userId: userId,
        timer: taskData.timer || null,
        youtubeUrl: taskData.youtubeUrl || null,
        scheduledDate: taskData.scheduledDate ? new Date(taskData.scheduledDate) : null,
        displayOrder: 0,
        isRecurring: false,
        recurringFrequency: null,
        recurringInterval: null,
        nextDueDate: null,
        endDate: null,
        daysOfWeek: null,
        dayOfMonth: null,
        monthOfYear: null,
        parentTaskId: null,
        archived: false,
        archivedAt: null,
        checklistItems: []
      };

      const newTask = await storage.createTask(taskInsert);
      return newTask;
    } catch (error) {
      console.error('Error creating task from chat:', error);
      throw new Error('Failed to create task');
    }
  }

  async createChecklistFromChat(checklistData: ChecklistCreationRequest, userId: number): Promise<Task> {
    try {
      const taskInsert: Omit<Task, "id" | "createdAt"> = {
        title: checklistData.title,
        category: checklistData.category || 'Personal',
        priority: checklistData.priority || 'Medium',
        completed: false,
        completedAt: null,
        userId: userId,
        timer: null,
        youtubeUrl: null,
        scheduledDate: null,
        displayOrder: 0,
        isRecurring: false,
        recurringFrequency: null,
        recurringInterval: null,
        nextDueDate: null,
        endDate: null,
        daysOfWeek: null,
        dayOfMonth: null,
        monthOfYear: null,
        parentTaskId: null,
        archived: false,
        archivedAt: null,
        checklistItems: checklistData.checklistItems.map((item, index) => ({
          ...item,
          id: `${Date.now()}-${index}`
        }))
      };

      const newTask = await storage.createTask(taskInsert);
      return newTask;
    } catch (error) {
      console.error('Error creating checklist from chat:', error);
      throw new Error('Failed to create checklist');
    }
  }

  async createRollingTasksFromChat(rollingData: RollingTasksRequest, userId: number): Promise<Task[]> {
    try {
      const createdTasks: Task[] = [];
      
      // Create each task in sequence
      for (const taskData of rollingData.tasks) {
        const taskInsert: Omit<Task, "id" | "createdAt"> = {
          title: taskData.title,
          category: taskData.category || 'Personal',
          priority: taskData.priority || 'Medium',
          completed: false,
          completedAt: null,
          userId: userId,
          timer: taskData.timer || null,
          youtubeUrl: taskData.youtubeUrl || null,
          scheduledDate: taskData.scheduledDate ? new Date(taskData.scheduledDate) : null,
          displayOrder: 0,
          isRecurring: false,
          recurringFrequency: null,
          recurringInterval: null,
          nextDueDate: null,
          endDate: null,
          daysOfWeek: null,
          dayOfMonth: null,
          monthOfYear: null,
          parentTaskId: null,
          archived: false,
          archivedAt: null,
          checklistItems: []
        };

        const newTask = await storage.createTask(taskInsert);
        createdTasks.push(newTask);
      }

      console.log(`Successfully created ${createdTasks.length} rolling tasks for user ${userId}`);
      return createdTasks;
    } catch (error) {
      console.error('Error creating rolling tasks from chat:', error);
      throw new Error('Failed to create rolling tasks');
    }
  }

  async analyzeTasks(userId: number): Promise<string> {
    try {
      const userTasks = await storage.getAllTasks(userId);
      
      if (userTasks.length === 0) {
        return "Your task portfolio is currently unallocated. I recommend we establish your strategic priorities immediately. What key deliverables shall we schedule for optimization?";
      }

      const completed = userTasks.filter((task: Task) => task.completed).length;
      const total = userTasks.length;
      const completionRate = Math.round((completed / total) * 100);

      const categoryBreakdown = userTasks.reduce((acc: Record<string, number>, task: Task) => {
        acc[task.category] = (acc[task.category] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      const priorityBreakdown = userTasks.reduce((acc: Record<string, number>, task: Task) => {
        acc[task.priority] = (acc[task.priority] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      return `Executive Task Portfolio Analysis:

PERFORMANCE METRICS:
‚Ä¢ Completion Rate: ${completionRate}% (${completed}/${total} deliverables executed)
‚Ä¢ Efficiency Rating: ${completionRate > 70 ? "EXCEPTIONAL" : completionRate > 50 ? "STRONG" : "DEVELOPING"}

PORTFOLIO ALLOCATION BY CATEGORY:
${Object.entries(categoryBreakdown).map(([cat, count]) => `‚Ä¢ ${cat}: ${count} strategic items`).join('\n')}

PRIORITY DISTRIBUTION:
${Object.entries(priorityBreakdown).map(([pri, count]) => `‚Ä¢ ${pri} Priority: ${count} actionable items`).join('\n')}

STRATEGIC RECOMMENDATION: ${completionRate > 70 ? 
  "Your execution metrics demonstrate exceptional performance. I recommend leveraging this momentum for high-impact initiatives." : 
  "Focus on high-priority deliverables to optimize your completion velocity and maximize ROI on time investment."}

How may I further optimize your productivity trajectory?`;
    } catch (error) {
      console.error('Error analyzing tasks:', error);
      return "I had trouble analyzing your tasks, but I'm here to help you stay organized! What can I assist you with?";
    }
  }

  async getProductivityTips(): Promise<string> {
    const tips = [
      "üçÖ **FOCUS Timer**: Use our built-in FOCUS Timer for perfect 25-minute work sessions with 5-minute breaks. It's the ideal way to implement the Pomodoro method right here in AICHECKLIST!",
      "üìù **Write it down**: Your brain is for having ideas, not storing them. Get those thoughts into tasks!",
      "üéØ **One priority**: Pick your most important task each morning and tackle it first when your energy is highest.",
      "‚è∞ **Time blocking**: Schedule specific times for different types of work. Your future self will thank you!",
      "üßπ **2-minute rule**: If a task takes less than 2 minutes, do it now instead of adding it to your list.",
      "üéâ **Celebrate wins**: Completed a task? Take a moment to feel proud! You earned it!",
      "üåÖ **Morning routine**: Start your day with intention. Review your tasks and set your priorities.",
      "üì± **Minimize distractions**: Put your phone in another room when focusing on important work."
    ];

    const randomTip = tips[Math.floor(Math.random() * tips.length)];
    
    return `${randomTip}

Remember, productivity isn't about being perfect - it's about making consistent progress! What area of productivity would you like to improve? I'm here to help! üí™‚ú®`;
  }
}

export const domoAI = new DomoAI();